<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LoopModels: CostModeling::Register::UsesAcrossBBs Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LoopModels
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>CostModeling</b></li><li class="navelem"><b>Register</b></li><li class="navelem"><a class="el" href="structCostModeling_1_1Register_1_1UsesAcrossBBs.html">UsesAcrossBBs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structCostModeling_1_1Register_1_1UsesAcrossBBs-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CostModeling::Register::UsesAcrossBBs Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCostModeling_1_1Register_1_1UsesAcrossBBs_1_1LiveInfo.html">LiveInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af711fb3ad911d11bde1692268659daaf"><td class="memItemLeft" align="right" valign="top"><a id="af711fb3ad911d11bde1692268659daaf"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:af711fb3ad911d11bde1692268659daaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a65051c67900e3bbc4da3d2d37c8a69ba"><td class="memItemLeft" align="right" valign="top"><a id="a65051c67900e3bbc4da3d2d37c8a69ba"></a>
math::Vector&lt; <a class="el" href="structCostModeling_1_1Register_1_1UsesAcrossBBs_1_1LiveInfo.html">LiveInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>liveinfo_</b></td></tr>
<tr class="separator:a65051c67900e3bbc4da3d2d37c8a69ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09ff826a684d37af816caef8ea56b7c"><td class="memItemLeft" align="right" valign="top"><a id="ad09ff826a684d37af816caef8ea56b7c"></a>
math::Vector&lt; u8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>live_counts_</b></td></tr>
<tr class="separator:ad09ff826a684d37af816caef8ea56b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Register Use Modeling The primary goal is to estimate spill costs. There are two components:</p><ol type="1">
<li>Costs paid on block entry.</li>
<li>Costs paid within a block. <code><a class="el" href="structCostModeling_1_1Register_1_1UsesAcrossBBs.html">UsesAcrossBBs</a></code> is the primary data structure concerned with costs paid on block entry. For data with lifetimes (definition to last-use) that span more than 1 block, it tracks uses and spill-states. In a block where they are used, any spilled variables must be reloaded. In a block where they aren't used, they still add to spill cost, but with the option of cheaper, hoisted spilling. Within a block, we use <code>LiveRegisters</code>, which contains <code>intrablock</code> and <code>interblock</code> sets. For the <code>intrablock</code>, we can consider unroll orders to reduce the register cost. These are temporary; the register cost is the product of all dependent loops unrolled interior to the first unrolled independent loop, as we can reuse the same register for each new unrolled value (dependent unrolls interior to an independent unroll are hoisted out, thus consuming registers). On the other hand, <code>interblock</code> is for uses that have lifetime rules forbidding this, e.g. because they must span blocks. For these, the unroll cost is the full product of all dependent loads. We may have multiple snapshots of <code>LiveRegisters</code> within a basic block. The <code>interblock</code>s are allowed to be consumed, e.g. the last use of a variable defined at the same depth, or an <code>accumPhi</code>. The <a class="el" href="structCostModeling_1_1Register_1_1UsesAcrossBBs_1_1LiveInfo.html">LiveInfo</a> objects with <code>UsedHere=1</code> indicate how much must be loaded as we enter a block. The <code>interblock</code> is for cost calculations.</li>
</ol>
<p>For <code>accumPhi</code>s, </p><pre class="fragment">v = foo();
for (int i = 0; i &lt; I; ++i){
  w = phi(v, y); // accum phi - counts as use of `v` but not `y`
  x = bar(w);
  y = qux(x);
}
z = phi(v, y); // join phi - counts as use of `y` but not `v`
</pre><p> we add the use of <code>v</code> in front of the loop, in the previous BB. This is because <code>v</code> is consumed before the loop, replaced with <code>w</code>. Only if it is also used elsewhere in the loop's BB would the BB need to dedicate registers.</p>
<p>This is used for tracking spills/liveness across BBs. The primary use of this is for estimating the cost of register spills.</p>
<p>Conceptually, the data structure represents a binary tree, rooted at the last BB. For each node, we have used/not used. Future use patterns merge, hence a binary tree rooted at the end. For example, while these start different (0101 vs 1010): 01011010101 10101010101 they fuse after BB#4 and no longer need separate tracking.</p>
<p>The last BB only needs 'used'; unused would have no uses left and thus be dropped. We don't hoist spilling of used, because they need to be loaded, thus, used aren't really tracked, either. Thus, the second-to-last BB is the "first" (if starting from the end) that we need data for.</p>
<p>To support the use of cost estimation, the data is organized by BB. It could be viewed as a vector of BBs, where each BB has a vector of all still relevant spill counts. The vector contains additions, as well as a field for live.</p>
<p>As part of computation, we also want to hoist spills out as far as we can. This means, we need to know if we have successive descents that also aren't uses.</p>
<p>For building this object, we additionally need to store the future use patterns. Phi nodes should be consumable w/in their own block; they represent memory (registers) set aside, but %1 = phi(%0, %3) %2 = A[0,i]*B[0,i] + %1 // last use within block %3 = %2 - A[1,i]*B[1,i] // %1 phi is user So, phi node should only count users within the block for <code>remainingUses</code>? Perhaps we should split remaining uses into a <code>std::array&lt;int32_t,2&gt;</code> (or custom struct) indicating uses within BB and uses without? </p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>mod/Optimize/RegisterLife.cxx</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
