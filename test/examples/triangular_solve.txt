remark: REPL[26]:8:0: there are 16 scalar registers
remark: REPL[26]:8:0: there are 32 vector registers
remark: REPL[26]:8:0: MemoryAccesses:
Inst:   %64 = load double, ptr addrspace(13) %63, align 8, !dbg !55, !tbaa !59
Order: [ 0, 0, 0 ]
Loop:Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
Order: [ 0, 0, 1 ]
Loop:Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   %71 = load double, ptr addrspace(13) %70, align 8, !dbg !66, !tbaa !59
Order: [ 0, 1, 0 ]
Loop:Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   %75 = load double, ptr addrspace(13) %74, align 8, !dbg !66, !tbaa !59
Order: [ 0, 1, 1 ]
Loop:Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
Order: [ 0, 1, 2 ]
Loop:Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
Order: [ 0, 1, 3, 0 ]
Loop:Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   %87 = load double, ptr addrspace(13) %86, align 8, !dbg !89, !tbaa !59
Order: [ 0, 1, 3, 1 ]
Loop:Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

Inst:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
Order: [ 0, 1, 3, 2 ]
Loop:Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20



remark: REPL[26]:8:0: Solved linear program:
LoopBlock graph (#nodes = 3):
v_0:
mem =
  %64 = load double, ptr addrspace(13) %63, align 8, !dbg !55, !tbaa !59
  store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
inNeighbors = 
outNeighbors = v_1, v_2, 

v_1:
mem =
  %71 = load double, ptr addrspace(13) %70, align 8, !dbg !66, !tbaa !59
  %75 = load double, ptr addrspace(13) %74, align 8, !dbg !66, !tbaa !59
  store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
inNeighbors = v_0, v_1, v_2, 
outNeighbors = v_1, v_2, 

v_2:
mem =
  store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
  %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
  %87 = load double, ptr addrspace(13) %86, align 8, !dbg !89, !tbaa !59
  store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
inNeighbors = v_0, v_1, v_2, 
outNeighbors = v_1, v_2, 


LoopBlock Edges (#edges = 10):

	Edge = Dependence Poly y -> x:
	Input:
Store:   store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 0, 1 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Load:   %71 = load double, ptr addrspace(13) %70, align 8, !dbg !66, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 0 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 0 1 0 0 -1  0
  -1 1 0 0 0  0 -1
   0 0 0 0 0  1  0
   0 0 0 0 0  0  1 ]
E = 
[ 0 0 0 1 0 -1  0
  0 0 0 0 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 0  0  0  0  0 -1 1  0  0 0 0 -1
  0 0  0  1 0 0  0  0  0  0  0 0  0  0 0 0  0
  0 0  1  0 0 0  0  0  0  0  0 0  0  0 0 0  0
  0 0  0  0 0 0  1  0 -1  0  0 0 -1  0 0 0  0
  0 0  0  0 0 0  0  1  0 -1  0 0  0 -1 0 0  0
  0 0 -1  0 1 0 -1  0  1  0  0 0  0  0 1 0  0
  0 0  0 -1 0 1  0 -1  0  1  0 0  0  0 0 1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 0  0  0  0  0 1 -1 0 0  0  0 -1  0  0
  0 0  0  1 0 0  0  0  0  0 0  0 0 0  0  0  0 -1  0
  0 0  1  0 0 0  0  0  0  0 0  0 0 0  0  0  0  0 -1
  0 0  0  0 0 0  1  0 -1  0 0  0 1 0  0  0  0  0  0
  0 0  0  0 0 0  0  1  0 -1 0  0 0 1  0  0  0  0  0
  0 0 -1  0 1 0 -1  0  1  0 0  0 0 0 -1  0  0  0  0
  0 0  0 -1 0 1  0 -1  0  1 0  0 0 0  0 -1  0  0  0 ]
Schedule In: nodeIndex = BitSet[0]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]



	Edge = Dependence Poly y -> x:
	Input:
Store:   store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 0, 1 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Store:   store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 2 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 0 1 0 0 -1  0
  -1 1 0 0 0  0 -1
   0 0 0 0 0  1  0
   0 0 0 0 0  0  1 ]
E = 
[ 0 0 0 1 0 -1  0
  0 0 0 0 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 0  0  0  0  0 -1 1  0  0 0 0 -1
  0 0  0  1 0 0  0  0  0  0  0 0  0  0 0 0  0
  0 0  1  0 0 0  0  0  0  0  0 0  0  0 0 0  0
  0 0  0  0 0 0  1  0 -1  0  0 0 -1  0 0 0  0
  0 0  0  0 0 0  0  1  0 -1  0 0  0 -1 0 0  0
  0 0 -1  0 1 0 -1  0  1  0  0 0  0  0 1 0  0
  0 0  0 -1 0 1  0 -1  0  1  0 0  0  0 0 1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 0  0  0  0  0 1 -1 0 0  0  0 -1  0  0
  0 0  0  1 0 0  0  0  0  0 0  0 0 0  0  0  0 -1  0
  0 0  1  0 0 0  0  0  0  0 0  0 0 0  0  0  0  0 -1
  0 0  0  0 0 0  1  0 -1  0 0  0 1 0  0  0  0  0  0
  0 0  0  0 0 0  0  1  0 -1 0  0 0 1  0  0  0  0  0
  0 0 -1  0 1 0 -1  0  1  0 0  0 0 0 -1  0  0  0  0
  0 0  0 -1 0 1  0 -1  0  1 0  0 0 0  0 -1  0  0  0 ]
Schedule In: nodeIndex = BitSet[0]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly y -> x:
	Input:
Load:   %71 = load double, ptr addrspace(13) %70, align 8, !dbg !66, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 0 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Store:   store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 2 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 0 1 0 0 -1  0
  -1 1 0 0 0  0 -1
   0 0 0 0 0  1  0
   0 0 0 0 0  0  1 ]
E = 
[ 0 0 0 1 0 -1  0
  0 0 0 0 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 0  0  0  0  0 -1 1  0  0 0 0 -1
  0 0  0  1 0 0  0  0  0  0  0 0  0  0 0 0  0
  0 0  1  0 0 0  0  0  0  0  0 0  0  0 0 0  0
  0 0  0  0 0 0  1  0 -1  0  0 0 -1  0 0 0  0
  0 0  0  0 0 0  0  1  0 -1  0 0  0 -1 0 0  0
  0 0 -1  0 1 0 -1  0  1  0  0 0  0  0 1 0  0
  0 0  0 -1 0 1  0 -1  0  1  0 0  0  0 0 1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 0  0  0  0  0 1 -1 0 0  0  0 -1  0  0
  0 0  0  1 0 0  0  0  0  0 0  0 0 0  0  0  0 -1  0
  0 0  1  0 0 0  0  0  0  0 0  0 0 0  0  0  0  0 -1
  0 0  0  0 0 0  1  0 -1  0 0  0 1 0  0  0  0  0  0
  0 0  0  0 0 0  0  1  0 -1 0  0 0 1  0  0  0  0  0
  0 0 -1  0 1 0 -1  0  1  0 0  0 0 0 -1  0  0  0  0
  0 0  0 -1 0 1  0 -1  0  1 0  0 0 0  0 -1  0  0  0 ]
Schedule In: nodeIndex = BitSet[1]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly y -> x:
	Input:
Store:   store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 0, 1 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Load:   %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 0 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 1 0 0 0  0  0 -1
  -1 0 1 0 0  0 -1  0
   0 0 0 0 0  1  0  0
  -1 0 0 0 0 -1  0  1
   0 0 0 0 0  0  1  0 ]
E = 
[ 0 0 0 1 0 0 -1  0
  1 0 0 0 1 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 -1 1  0  0  0 0 0 -1
  0 0  1  0 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0
  0 0  0  1 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0
  0 0  0  0 0  0 0  1  0 -1  0  0 0 -1  0  0 0 0  0
  0 0  0  0 0  0 0  0  1  0 -1  0 0  0 -1  0 0 0  0
  0 0  0  0 1 -1 0  0  1  0 -1  0 0  0  0 -1 0 0  0
  0 0  0 -1 0  0 1 -1  0  1  0  0 0  0  0  0 1 0  0
  0 0 -1  0 0  1 0  0 -1  0  1  0 0  0  0  0 0 1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 1 -1 0 0 0  0  0 -1  0  0
  0 0  1  0 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0 -1  0
  0 0  0  1 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0  0 -1
  0 0  0  0 0  0 0  1  0 -1  0 0  0 1 0 0  0  0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1 0  0 0 1 0  0  0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1 0  0 0 0 1  0  0  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0 0  0 0 0 0 -1  0  0  0  0
  0 0 -1  0 0  1 0  0 -1  0  1 0  0 0 0 0  0 -1  0  0  0 ]
Schedule In: nodeIndex = BitSet[0]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly x -> y:
	Input:
Load:   %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 0 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Store:   store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 2 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 1 0 0 0  0  0 -1
  -1 0 1 0 0  0 -1  0
   0 0 0 0 0  1  0  0
  -1 0 0 0 0 -1  0  1
   0 0 0 0 0  0  1  0 ]
E = 
[ 0 0 0 1 0 0 -1  0
  1 0 0 0 1 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 1 -1 0 0 0  0  0 -1
  0 0  1  0 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0
  0 0  0  1 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0
  0 0  0  0 0  0 0  1  0 -1  0 0  0 1 0 0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1 0  0 0 1 0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1 0  0 0 0 1  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0 0  0 0 0 0 -1  0  0
  0 0 -1  0 0  1 0  0 -1  0  1 0  0 0 0 0  0 -1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 -1 1  0  0  0 0 0 -1  0  0
  0 0  1  0 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0 -1  0
  0 0  0  1 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0  0 -1
  0 0  0  0 0  0 0  1  0 -1  0  0 0 -1  0  0 0 0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1  0 0  0 -1  0 0 0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1  0 0  0  0 -1 0 0  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0  0 0  0  0  0 1 0  0  0  0
  0 0 -1  0 0  1 0  0 -1  0  1  0 0  0  0  0 0 1  0  0  0 ]
Schedule In: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly y -> x:
	Input:
Store:   store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 0, 1 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Store:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 2 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 1 0 0 0  0  0 -1
  -1 0 1 0 0  0 -1  0
   0 0 0 0 0  1  0  0
  -1 0 0 0 0 -1  0  1
   0 0 0 0 0  0  1  0 ]
E = 
[ 0 0 0 1 0 0 -1  0
  1 0 0 0 1 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 -1 1  0  0  0 0 0 -1
  0 0  1  0 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0
  0 0  0  1 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0
  0 0  0  0 0  0 0  1  0 -1  0  0 0 -1  0  0 0 0  0
  0 0  0  0 0  0 0  0  1  0 -1  0 0  0 -1  0 0 0  0
  0 0  0  0 1 -1 0  0  1  0 -1  0 0  0  0 -1 0 0  0
  0 0  0 -1 0  0 1 -1  0  1  0  0 0  0  0  0 1 0  0
  0 0 -1  0 0  1 0  0 -1  0  1  0 0  0  0  0 0 1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 1 -1 0 0 0  0  0 -1  0  0
  0 0  1  0 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0 -1  0
  0 0  0  1 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0  0 -1
  0 0  0  0 0  0 0  1  0 -1  0 0  0 1 0 0  0  0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1 0  0 0 1 0  0  0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1 0  0 0 0 1  0  0  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0 0  0 0 0 0 -1  0  0  0  0
  0 0 -1  0 0  1 0  0 -1  0  1 0  0 0 0 0  0 -1  0  0  0 ]
Schedule In: nodeIndex = BitSet[0]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly x -> y:
	Input:
Store:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 2 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Load:   %71 = load double, ptr addrspace(13) %70, align 8, !dbg !66, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 0 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 1 0 0 0  0  0 -1
  -1 0 1 0 0  0 -1  0
   0 0 0 0 0  1  0  0
  -1 0 0 0 0 -1  0  1
   0 0 0 0 0  0  1  0 ]
E = 
[ 0 0 0 1 0 0 -1  0
  1 0 0 0 1 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 1 -1 0 0 0  0  0 -1
  0 0  1  0 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0
  0 0  0  1 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0
  0 0  0  0 0  0 0  1  0 -1  0 0  0 1 0 0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1 0  0 0 1 0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1 0  0 0 0 1  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0 0  0 0 0 0 -1  0  0
  0 0 -1  0 0  1 0  0 -1  0  1 0  0 0 0 0  0 -1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 -1 1  0  0  0 0 0 -1  0  0
  0 0  1  0 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0 -1  0
  0 0  0  1 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0  0 -1
  0 0  0  0 0  0 0  1  0 -1  0  0 0 -1  0  0 0 0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1  0 0  0 -1  0 0 0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1  0 0  0  0 -1 0 0  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0  0 0  0  0  0 1 0  0  0  0
  0 0 -1  0 0  1 0  0 -1  0  1  0 0  0  0  0 0 1  0  0  0 ]
Schedule In: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]

Schedule Out: nodeIndex = BitSet[1]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]



	Edge = Dependence Poly x -> y:
	Input:
Store:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 2 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Store:   store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 2 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -1 1 0 0 0  0  0 -1
  -1 0 1 0 0  0 -1  0
   0 0 0 0 0  1  0  0
  -1 0 0 0 0 -1  0  1
   0 0 0 0 0  0  1  0 ]
E = 
[ 0 0 0 1 0 0 -1  0
  1 0 0 0 1 1  0 -1 ]
Schedule Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 1 -1 0 0 0  0  0 -1
  0 0  1  0 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0
  0 0  0  1 0  0 0  0  0  0  0 0  0 0 0 0  0  0  0
  0 0  0  0 0  0 0  1  0 -1  0 0  0 1 0 0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1 0  0 0 1 0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1 0  0 0 0 1  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0 0  0 0 0 0 -1  0  0
  0 0 -1  0 0  1 0  0 -1  0  1 0  0 0 0 0  0 -1  0 ]
Bounding Constraints:
[ 0 1 -1 -1 0 -1 0  0  1  0 -1 -1 1  0  0  0 0 0 -1  0  0
  0 0  1  0 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0 -1  0
  0 0  0  1 0  0 0  0  0  0  0  0 0  0  0  0 0 0  0  0 -1
  0 0  0  0 0  0 0  1  0 -1  0  0 0 -1  0  0 0 0  0  0  0
  0 0  0  0 0  0 0  0  1  0 -1  0 0  0 -1  0 0 0  0  0  0
  0 0  0  0 1 -1 0  0  1  0 -1  0 0  0  0 -1 0 0  0  0  0
  0 0  0 -1 0  0 1 -1  0  1  0  0 0  0  0  0 1 0  0  0  0
  0 0 -1  0 0  1 0  0 -1  0  1  0 0  0  0  0 0 1  0  0  0 ]
Schedule In: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

Schedule Out: nodeIndex = BitSet[1, 2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly y -> x:
	Input:
Load:   %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 0 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Store:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 2 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -2 1 0 0 0 0  0 -1 -1 0
  -1 0 1 0 0 0 -1  0  0 0
   0 0 0 0 0 0  0  0  1 0
   0 0 0 0 0 0  0  1  0 0
   0 0 0 0 0 0  1  0  0 0
   0 0 0 0 0 1  0  1 -1 1
   0 0 0 0 0 1  0  0  0 0 ]
E = 
[ 0 0 0 1 0 0 -1  0  0 0
  0 0 0 0 1 1  0 -1 -1 0
  0 0 0 0 0 2  0  0 -2 1 ]
Schedule Constraints:
[ 0 1 -2 -1 0 0 0  0 0  0  0  0  0  0  0 -1 1  0  0  0 0 0 0 -1
  0 0  1  0 0 0 0  0 0  0  0  0  0  0  0  0 0  0  0  0 0 0 0  0
  0 0  0  1 0 0 0  0 0  0  0  0  0  0  0  0 0  0  0  0 0 0 0  0
  0 0  0  0 0 0 0  0 0  1  0  0 -1  0  0  0 0 -1  0  0 0 0 0  0
  0 0  0  0 0 0 0  0 0  0  1  0  0 -1  0  0 0  0 -1  0 0 0 0  0
  0 0  0  0 0 0 0  1 1  0  1  2  0 -1 -2  0 0  0  0 -1 0 0 0  0
  0 0  0 -1 0 0 1  0 0 -1  0  0  1  0  0  0 0  0  0  0 1 0 0  0
  0 0 -1  0 0 1 0  1 0  0 -1  0  0  1  0  0 0  0  0  0 0 1 0  0
  0 0 -1  0 1 0 0 -1 0  0 -1 -2  0  1  2  0 0  0  0  0 0 0 1  0 ]
Bounding Constraints:
[ 0 1 -2 -1 0 0 0  0 0  0  0  0  0  0  0 1 -1 0 0 0  0  0  0 -1  0  0
  0 0  1  0 0 0 0  0 0  0  0  0  0  0  0 0  0 0 0 0  0  0  0  0 -1  0
  0 0  0  1 0 0 0  0 0  0  0  0  0  0  0 0  0 0 0 0  0  0  0  0  0 -1
  0 0  0  0 0 0 0  0 0  1  0  0 -1  0  0 0  0 1 0 0  0  0  0  0  0  0
  0 0  0  0 0 0 0  0 0  0  1  0  0 -1  0 0  0 0 1 0  0  0  0  0  0  0
  0 0  0  0 0 0 0  1 1  0  1  2  0 -1 -2 0  0 0 0 1  0  0  0  0  0  0
  0 0  0 -1 0 0 1  0 0 -1  0  0  1  0  0 0  0 0 0 0 -1  0  0  0  0  0
  0 0 -1  0 0 1 0  1 0  0 -1  0  0  1  0 0  0 0 0 0  0 -1  0  0  0  0
  0 0 -1  0 1 0 0 -1 0  0 -1 -2  0  1  2 0  0 0 0 0  0  0 -1  0  0  0 ]
Schedule In: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]

Schedule Out: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



	Edge = Dependence Poly x -> y:
	Input:
Store:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 2 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

	Output:
Load:   %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 0 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

A = 
[ -2 1 0 0 0 0  0 -1 -1 0
  -1 0 1 0 0 0 -1  0  0 0
   0 0 0 0 0 0  0  0  1 0
   0 0 0 0 0 0  0  1  0 0
   0 0 0 0 0 0  1  0  0 0
  -2 0 0 0 0 1  0  1 -1 1
   0 0 0 0 0 1  0  0  0 0 ]
E = 
[  0 0 0 1 0 0 -1  0  0 0
   0 0 0 0 1 1  0 -1 -1 0
  -2 0 0 0 0 2  0  0 -2 1 ]
Schedule Constraints:
[ 0 1 -2 -1 0 0 0 -2 0  0  0 -2  0  0  2 1 -1 0 0 0  0  0  0 -1
  0 0  1  0 0 0 0  0 0  0  0  0  0  0  0 0  0 0 0 0  0  0  0  0
  0 0  0  1 0 0 0  0 0  0  0  0  0  0  0 0  0 0 0 0  0  0  0  0
  0 0  0  0 0 0 0  0 0  1  0  0 -1  0  0 0  0 1 0 0  0  0  0  0
  0 0  0  0 0 0 0  0 0  0  1  0  0 -1  0 0  0 0 1 0  0  0  0  0
  0 0  0  0 0 0 0  1 1  0  1  2  0 -1 -2 0  0 0 0 1  0  0  0  0
  0 0  0 -1 0 0 1  0 0 -1  0  0  1  0  0 0  0 0 0 0 -1  0  0  0
  0 0 -1  0 0 1 0  1 0  0 -1  0  0  1  0 0  0 0 0 0  0 -1  0  0
  0 0 -1  0 1 0 0 -1 0  0 -1 -2  0  1  2 0  0 0 0 0  0  0 -1  0 ]
Bounding Constraints:
[ 0 1 -2 -1 0 0 0 -2 0  0  0 -2  0  0  2 -1 1  0  0  0 0 0 0 -1  0  0
  0 0  1  0 0 0 0  0 0  0  0  0  0  0  0  0 0  0  0  0 0 0 0  0 -1  0
  0 0  0  1 0 0 0  0 0  0  0  0  0  0  0  0 0  0  0  0 0 0 0  0  0 -1
  0 0  0  0 0 0 0  0 0  1  0  0 -1  0  0  0 0 -1  0  0 0 0 0  0  0  0
  0 0  0  0 0 0 0  0 0  0  1  0  0 -1  0  0 0  0 -1  0 0 0 0  0  0  0
  0 0  0  0 0 0 0  1 1  0  1  2  0 -1 -2  0 0  0  0 -1 0 0 0  0  0  0
  0 0  0 -1 0 0 1  0 0 -1  0  0  1  0  0  0 0  0  0  0 1 0 0  0  0  0
  0 0 -1  0 0 1 0  1 0  0 -1  0  0  1  0  0 0  0  0  0 0 1 0  0  0  0
  0 0 -1  0 1 0 0 -1 0  0 -1 -2  0  1  2  0 0  0  0  0 0 0 1  0  0  0 ]
Schedule In: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]

Schedule Out: nodeIndex = BitSet[2]
s.getPhi() =
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]


LoopBlock schedule (#mem accesses = 8):

Ref = Load:   %64 = load double, ptr addrspace(13) %63, align 8, !dbg !55, !tbaa !59
ArrayReference %52 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 0, 0 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 0
s.getPhi()
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]
Ref = Store:   store double %64, ptr addrspace(13) %65, align 8, !dbg !61, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 0, 1 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 0
s.getPhi()
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]
Ref = Load:   %71 = load double, ptr addrspace(13) %70, align 8, !dbg !66, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 0 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 1
s.getPhi()
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]
Ref = Load:   %75 = load double, ptr addrspace(13) %74, align 8, !dbg !66, !tbaa !59
ArrayReference %58 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %23 ]
Subscripts: [ i_1 , i_1 ]
Initial Fusion Omega: [ 0, 1, 1 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 1
s.getPhi()
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]
Ref = Store:   store double %76, ptr addrspace(13) %70, align 8, !dbg !71, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 2, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1 , i_0 ]
Initial Fusion Omega: [ 0, 1, 2 ]
AffineLoopNest:
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -1 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 1
s.getPhi()
[ 0 1
  1 0 ]
s.getFusionOmega() = [ 0, 0, 0 ]
s.getOffsetOmega() = [ 0, 0 ]

nodeIndex = 2
s.getPhi()
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]
Ref = Load:   %83 = load double, ptr addrspace(13) %82, align 8, !dbg !89, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 0 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 2
s.getPhi()
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]
Ref = Load:   %87 = load double, ptr addrspace(13) %86, align 8, !dbg !89, !tbaa !59
ArrayReference %58 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %23 ]
Subscripts: [ i_1  + i_2  + 1, i_1 ]
Initial Fusion Omega: [ 0, 1, 3, 1 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 2
s.getPhi()
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]
Ref = Store:   store double %89, ptr addrspace(13) %82, align 8, !dbg !95, !tbaa !59
ArrayReference %55 (dim = 2, num loops: 3, element size: 8):
Sizes: [ unknown, %20 ]
Subscripts: [ i_1  + i_2  + 1, i_0 ]
Initial Fusion Omega: [ 0, 1, 3, 2 ]
AffineLoopNest:
Loop 2 lower bounds: i_2 >= 0
Loop 2 upper bounds: i_2 <= -2 + %23 - i_1
Loop 1 lower bounds: i_1 >= 0
Loop 1 upper bounds: i_1 <= -2 + %23
Loop 0 lower bounds: i_0 >= 0
Loop 0 upper bounds: i_0 <= -1 + %20

nodeIndex = 2
s.getPhi()
[ 0 1 1
  1 0 0
  0 1 0 ]
s.getFusionOmega() = [ 0, 0, 0, 0 ]
s.getOffsetOmega() = [ 1, 0, 0 ]



