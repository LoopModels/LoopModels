<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LoopModels: LoopModels</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LoopModels
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">LoopModels </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://codecov.io/github/JuliaSIMD/LoopModels"><img src="https://codecov.io/github/JuliaSIMD/LoopModels/branch/main/graph/badge.svg?token=nokmK2kmhT" alt="codecov" style="pointer-events: none;" class="inline"/></a> <a href="https://juliasimd.github.io/LoopModels/"><img src="https://img.shields.io/badge/docs-LoopModels-blue.svg" alt="Global Docs" style="pointer-events: none;" class="inline"/></a></p>
<h5>Description</h5>
<p>LoopModels is intended to be the successor to <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization.jl</a> and the <a href="https://github.com/JuliaSIMD/">JuliaSIMD</a> ecosystem.</p>
<p>It is a work in progress, it will probably be many months before it achieves the level of completeness needed for a working prototype capable of compiling LLVM IR.</p>
<p>Compared to <code>LoopVectorization.jl</code>, the initial release of LoopModels will lack support for threading, as well as for non-affine indexing. However, <code>LoopModels</code> will correctly handle dependencies, support arbitrary affine loop nests (e.g. triangular loops and loops with multiple loops at the same level), and (by virtue of working on the LLVM level) will support arbitrary higher level data types. The goal for the initial release is for naively written operations on small arrays (fits in L2 cache) such as triangular solves and cholesky factorizations will be as close to optimal as can be reasonably achieved on the hardware, at least matching specialized libraries like MKL and OpenBLAS when single threaded over this range.</p>
<p>A longer term goal is also to ensure it works well with Enzyme, so that one can (for example) write simple/naive loops for machine learning or Bayesian models, and then get more or less optimal code for both the forward and reverse passes for gradient-based optimization and sampling algorithms.</p>
<p>Next in the road map will be support automatic cache tiling. Eventually, threading support is intended.</p>
<p>A high level overview of intended operation:</p><ol type="1">
<li>Convert memory accesses from LLVM IR to an internal representation.</li>
<li>Use polyhedral methods to analyze dependencies.</li>
<li>Search for register tiling oportunties; check legality. Try to apply fixes, if illegal. If we found a legal schedule, jump to <code>6</code>.</li>
<li>If <code>3.</code> fails, run an ILP solver to find a legal schedule, and then.</li>
<li>Apply optimizations to all parallelizable, tileable, and permutable hyperplanes.</li>
<li>Emit LLVM.</li>
</ol>
<p>Optimization algorithms (i.e., steps <code>3.</code> and <code>5.</code>) and code generation will take all the lessons learned from <code>LoopVectorization.jl</code>, which boasts impressive performance improvements on many loops (particularly on CPUs with AVX512) vs alternatives, but with the addition of actually performing dependence analysis to check for legality.</p>
<p>To assist with optimizations, <code>LoopModel</code>s will be allowed to move blocks ending in <code>unreachable</code> earlier. That is, if your code would throw an error, it will still do so, but perhaps at an earlier point. This will, for example, allow hoisting bounds checks out of a loop. It is expected that in many cases, bounds checks will actually provide information enabling analysis (i.e., delinearization), such that performance will actually be better with bounds checking enabled than disabled (front ends will be able to use <code>@llvm.assume</code>s to convey the necessary information if they really want to disable bounds checking).</p>
<p><code>LoopModels</code> will provide a function pass.</p>
<p>Some details and explanations will be provided at <a href="https://spmd.org/">spmd.org</a>.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Getting Started</h3>
<p>This project requires C++20. On Ubuntu 22.04 LTS or later (if you're on an older Ubuntu, I suggest upgrading), you can install the dependencies via </p><div class="fragment"><div class="line"># needed to build; g++ also works in place of clang</div>
<div class="line">sudo apt install meson clang llvm-dev libgtest-dev libbenchmark-dev ninja-build pkg-config cmake libc++-15-dev</div>
<div class="line"># quality of life</div>
<div class="line">sudo apt install clangd clang-format ccache lld gcovr</div>
</div><!-- fragment --><p> On Fedora 36: </p><div class="fragment"><div class="line">sudo dnf install meson clang llvm-devel gtest-devel google-benchmark-devel ninja-build pkgconf cmake</div>
<div class="line">sudo dnf install clang-tools-extra ccache lld libasan</div>
</div><!-- fragment --><p> I did not start from a clean ubuntu or fedora, so some dependencies may be missing.</p>
<p>Then to build and run the test suite, simply run </p><div class="fragment"><div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;&quot; meson setup builddir -Db_santize=address,undefined -Db_coverage=true</div>
<div class="line">cd builddir</div>
<div class="line">meson test</div>
<div class="line">cd .. &amp;&amp; ninja coverage -C builddir</div>
</div><!-- fragment --><p> Recompiling and rerunning tests simply requires rerunning <code>meson test</code>. The address sanitizer works for me on Fedora, but not Ubuntu (it has linking errors on Ubuntu, not unsanitary addresses ;) ), so you can remove it if it gives you trouble. Or find out how to actually get it working on Ubuntu and let me know.</p>
<p>If you chose a directory name other than <code>builddir</code>, you may want to update the symbolically linked file <code>compile_commands.json</code>, as <code>clangd</code> will in your editor will likely be looking for this (and use it for example to find your header files).</p>
<p>Benchmarks can be run via <code>meson test benchmarks</code>, which isn't that useful as it benchmarks the benchmark scripts. <code>meson</code>'s benchmark support seems ideal for macro benchmarks, which this project doesn't currently have. This repository currently only has a few micro benchmarks making use of <a href="https://github.com/google/benchmark">google benchmark</a>, which I should probably change to no longer mark as benchmarks w/ respect to <code>meson</code>, but as separate targets. These can be run via (or optionally <code>meson compile</code> to build all targets). </p><div class="fragment"><div class="line">meson compile polynomial_benchmark constraint_pruning_benchmark</div>
<div class="line">./polynomial_benchmark</div>
<div class="line">./constraint_pruning_benchmark</div>
</div><!-- fragment --><h5>No Root</h5>
<p>If you don't have root, or are using an operating system with package managers less wieldy than manual package management... Make sure you've defined the environmental variables on Linux: </p><div class="fragment"><div class="line">export PATH=$HOME/.local/bin:$PATH</div>
<div class="line">export LD_LIBRARY_PATH=$HOME/.local/lib/x86_64-unknown-linux-gnu/:$HOME/.local/lib:$LD_LIBRARY_PATH</div>
<div class="line">export PKG_CONFIG_PATH=$HOME/.local/lib/pkgconfig:$PKG_CONFIG_PATH</div>
<div class="line">export C_INCLUDE_PATH=$HOME/.local/include:$C_INCLUDE_PATH</div>
<div class="line">export CPLUS_INCLUDE_PATH=$HOME/.local/include:$CPLUS_INCLUDE_PATH</div>
</div><!-- fragment --><p> Or on MacOS: </p><div class="fragment"><div class="line">export SDKROOT=$(xcrun --show-sdk-path)</div>
<div class="line">export PATH=$HOME/.local/bin:$PATH</div>
<div class="line">export LD_LIBRARY_PATH=$HOME/.local/lib/x86_64-unknown-linux-gnu/:$HOME/.local/lib:$LD_LIBRARY_PATH</div>
<div class="line">export PKG_CONFIG_PATH=$HOME/.local/lib/pkgconfig:$PKG_CONFIG_PATH</div>
<div class="line">export C_INCLUDE_PATH=$HOME/.local/include:$C_INCLUDE_PATH</div>
<div class="line">export CPLUS_INCLUDE_PATH=$HOME/.local/include/c++/v1:$HOME/.local/include:$CPLUS_INCLUDE_PATH</div>
</div><!-- fragment --><p>You should probably place these in a script you can easily source it whenever you're developing LoopModels. Alternatively, place this in your <code>~/.bashrc</code> or equivalent. These paths will let the compiler and linker find the new LLVM tool chain.</p>
<div class="fragment"><div class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</div>
<div class="line">python3 get-pip.py</div>
<div class="line">python3 -m pip install meson --user</div>
<div class="line">rm get-pip.py</div>
<div class="line">mkdir -p $HOME/Documents/libraries</div>
<div class="line">cd $HOME/Documents/libraries</div>
<div class="line">git clone https://github.com/llvm/llvm-project.git</div>
<div class="line">cd llvm-project</div>
<div class="line">git checkout release/14.x</div>
<div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake -G Ninja -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLVM_USE_SPLIT_DWARF=ON -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_ENABLE_PROJECTS=&quot;mlir;clang;lld;clang-tools-extra&quot; -DLLVM_TARGETS_TO_BUILD=&quot;host&quot; -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=&quot;$HOME/.local&quot; -DLLVM_PARALLEL_LINK_JOBS=1 -DLLVM_OPTIMIZED_TABLEGEN=ON -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi;libunwind;compiler-rt&quot; ../llvm</div>
<div class="line">time ninja</div>
<div class="line">ninja install</div>
</div><!-- fragment --><p> You've now build a new enough toolchain that the project can use, both for linking with (LoopModels depends on LLVM &gt;= 14) and for compiling the project (LoopModels uses C++20). The project and all its dependencies will have to be built with and link to this toolchain, so it's important to set <code>CXXFLAGS="-stdlib=libc++"</code> below.</p>
<p>When building LLVM, if you have a lot of RAM, you can remove the option <code>-DLLVM_PARALLEL_LINK_JOBS=1</code> to allow parallel linking. If your RAM is limited, the OOM Killer is likely to hit your build.</p>
<p>If you're on MacOS, remove the <code>*_LD</code>s, as <code>lld</code> won't work. Or you could try replacing <code>lld</code> with <code>ld64.lld</code>. The default linker on Linux is slow, which is why I'm using the <code>lld</code> we build with llvm below. </p><div class="fragment"><div class="line">cd $HOME/Documents/libraries</div>
<div class="line">git clone https://github.com/google/benchmark.git</div>
<div class="line">cd benchmark</div>
<div class="line">cmake -E make_directory &quot;build&quot;</div>
<div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;-stdlib=libc++&quot; CC=clang CXX=clang++ cmake -E chdir &quot;build&quot; cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_INSTALL_PREFIX=&quot;$HOME/.local&quot; -DCMAKE_BUILD_TYPE=Release ../</div>
<div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;-stdlib=libc++&quot; CC=clang CXX=clang++ cmake --build &quot;build&quot; --config Release --target install</div>
<div class="line"> </div>
<div class="line">cd $HOME/Documents/libraries</div>
<div class="line">git clone https://github.com/google/googletest.git</div>
<div class="line">cd googletest</div>
<div class="line">cmake -E make_directory &quot;build&quot;</div>
<div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;-stdlib=libc++&quot; CC=clang CXX=clang++ cmake -E chdir &quot;build&quot; cmake -DCMAKE_INSTALL_PREFIX=&quot;$HOME/.local&quot; -DCMAKE_BUILD_TYPE=Release ../</div>
<div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;-stdlib=libc++&quot; CC=clang CXX=clang++ cmake --build &quot;build&quot; --config Release --target install</div>
</div><!-- fragment --><p> Now that all our dependencies are built, we can finally build <code>LoopModels</code> itself. It of course also requires <code>libc++</code>. </p><div class="fragment"><div class="line">cd $HOME/Documents/libraries</div>
<div class="line">git clone https://github.com/JuliaSIMD/LoopModels.git</div>
<div class="line">cd LoopModels</div>
<div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;-stdlib=libc++&quot; CC=clang CXX=clang++ meson setup builddir -Db_santize=address,undefined -Db_coverage=true</div>
<div class="line">cd builddir</div>
<div class="line">meson test</div>
<div class="line">cd .. &amp;&amp; ninja coverage -C builddir</div>
</div><!-- fragment --><p>Now that this is all set up, you just need to make sure the environmental variables are defined, and can just reinvoke <code>meson test</code> and <code>meson compile</code> to build the test suite/project as needed.</p>
<p>If you need to wipe the build dir, you'll have to set the temporary environment variables such as the linkers and CXX flags again.</p>
<h5>Custom LLVM</h5>
<p>By default, meson uses llvm-config to find LLVM. If you have several LLVM distributives installed, you can use meson <a href="https://mesonbuild.com/Native-environments.html">native file</a> to specify which LLVM is used when compiling LoopModels. The <code>.ini</code> file should override where to find llvm-config. For example, the contents of the <code>custom-llvm.ini</code> file specify the path to llvm-config </p><div class="fragment"><div class="line">llvm-config = &#39;/usr/local/bin/llvm/llvm-config&#39;</div>
</div><!-- fragment --><p>Then meson is configured with </p><div class="fragment"><div class="line">CC_LD=lld CXX_LD=lld CXXFLAGS=&quot;&quot; meson setup builddir -Db_santize=address,undefined --native-file custom-llvm.ini</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2"></a>
Notes on Code</h3>
<p>Eventually, I'd like to make didactic developer docs so that it's a useful resource for anyone wanting to learn about loop optimization and jump into the code to try implementing or improving optimizations.</p>
<p>For now, a few notes on conventions:</p>
<h5># Loop Order in internal data structures</h5>
<p>Loop orders are initially parsed such that their internal representation is inner &lt;-&gt; outer, i.e. the inner most loop would be indexed with <code>0</code>, and the outermost with <code>maxDepth - 1</code>.</p>
<p>This convention is more convenient for initially parsing loops as well as for the initial pass of ILP reordering.</p>
<p>When parsing loops, we take the largest sets we can model at a time. Thus it's natural to start with the innermost loop, and then move outwards, appending additional data. When we encounter something we cannot model, such as non-affine loop bounds or array accesses, we can also easily drop all outer loops, keeping the inner loops that satisfy our requirements. Thus, inner &lt;-&gt; outer is more convenient for parsing.</p>
<p>For ILP optimization, we take the lexicographical minimum of the <code>[dependence distance; schedule]</code> vector where the schedule is linearly independent of all previously solved schedules. By ordering inner &lt;-&gt; outer, we favor preserving the original program order rather than arbitrarily permuting. However, when printing, loops are named outer&lt;-&gt;inner, as we may be printing many loops of different depths, and this eases comparisons (i.e., we want $i_0$ to mean the same thing across fused loops!).</p>
<p>In contrast, schedules represent loops in an outer &lt;-&gt; inner order, as that is the order we solve them. That is columns of <code>Phi</code> and elements from <code>omega</code> are in outer &lt;-&gt; inner order.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Benchmarks</h3>
<p>You may first want to install <code>libpmf</code>, for example on Fedora </p><div class="fragment"><div class="line">sudo dnf install libpfm-devel libpfm-static</div>
</div><!-- fragment --><p> or on Debian(-based) systems: </p><div class="fragment"><div class="line">sudo apt-get install libpfm4-dev</div>
</div><!-- fragment --><p> <code>libpmf</code> is only necessary if you want perf counters. For example </p><div class="fragment"><div class="line">CXX=clang++ CXXFLAGS=&quot;&quot; cmake -G Ninja -S benchmark buildclang/benchmark -DCMAKE_BUILD_TYPE=Release</div>
<div class="line">cmake --build buildclang/benchmark</div>
<div class="line">buildclang/benchmark/LoopModelsBenchmarks --benchmark_perf_counters=CYCLES,INSTRUCTIONS,CACHE-MISSES</div>
<div class="line"> </div>
<div class="line">CXX=g++ CXXFLAGS=&quot;&quot; cmake -G Ninja -S benchmark buildgcc/benchmark -DCMAKE_BUILD_TYPE=Release</div>
<div class="line">cmake --build buildgcc/benchmark</div>
<div class="line">buildgcc/benchmark/LoopModelsBenchmarks --benchmark_perf_counters=CYCLES,INSTRUCTIONS,CACHE-MISSES</div>
</div><!-- fragment --><p> Only up to 3 arguments may be passed to <code>--benchmark_perf_counter</code> at a time. Additional options include <code>BRANCHES</code>, and architecture-specific event names like you'd use with <code>perf</code>. Some options you can try include: <code>cpu-cycles</code>,<code>task-clock</code>,<code>instructions</code>,<code>branch-instructions</code>,<code>branch-misses</code>, <code>L1-dcache-load-misses</code>, <code>L1-dcache-loads</code>, <code>cache-misses</code>, <code>cache-references</code>.</p>
<p>Google benchmark calls <a href="https://man7.org/linux/man-pages/man3/pfm_get_os_event_encoding.3.html">pfm_get_os_event_encoding</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
