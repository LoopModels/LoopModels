<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LoopModels: poly::lp::LinearProgramLoopBlock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LoopModels
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>poly</b></li><li class="navelem"><b>lp</b></li><li class="navelem"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html">LinearProgramLoopBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpoly_1_1lp_1_1LinearProgramLoopBlock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">poly::lp::LinearProgramLoopBlock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="LoopBlock_8hpp_source.html">LoopBlock.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1OutNeighbors.html">OutNeighbors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdd29fd47097b13ba0dfd026300bee0f"><td class="memItemLeft" align="right" valign="top"><a id="acdd29fd47097b13ba0dfd026300bee0f"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>setLI</b> (llvm::LoopInfo *loopInfo)</td></tr>
<tr class="separator:acdd29fd47097b13ba0dfd026300bee0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5b77e3452548088f2590caa593226a"><td class="memItemLeft" align="right" valign="top"><a id="a5d5b77e3452548088f2590caa593226a"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>addAddr</b> (<a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> *addr)</td></tr>
<tr class="separator:a5d5b77e3452548088f2590caa593226a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb144277abaf1e1110ab128ff16802e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#aeb144277abaf1e1110ab128ff16802e3">truncate</a> (size_t numToDrop, llvm::Loop *L, llvm::ScalarEvolution *SE)</td></tr>
<tr class="separator:aeb144277abaf1e1110ab128ff16802e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2258c8c54ab21ec767b89d1d340f52f"><td class="memItemLeft" align="right" valign="top"><a id="ab2258c8c54ab21ec767b89d1d340f52f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ab2258c8c54ab21ec767b89d1d340f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79112d00d627a49e53b6e9c8379e3242"><td class="memItemLeft" align="right" valign="top"><a id="a79112d00d627a49e53b6e9c8379e3242"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getAllocator</b> () -&gt; BumpAlloc&lt;&gt; &amp;</td></tr>
<tr class="separator:a79112d00d627a49e53b6e9c8379e3242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae619f421cec28285619119c1b23c9ad"><td class="memItemLeft" align="right" valign="top"><a id="aae619f421cec28285619119c1b23c9ad"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>numVerticies</b> () const -&gt; size_t</td></tr>
<tr class="separator:aae619f421cec28285619119c1b23c9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d52a5d9146d4bf3d5337d8a7689e7a5"><td class="memItemLeft" align="right" valign="top"><a id="a2d52a5d9146d4bf3d5337d8a7689e7a5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getVerticies</b> () -&gt; MutPtrVector&lt; <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &gt;</td></tr>
<tr class="separator:a2d52a5d9146d4bf3d5337d8a7689e7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbc728f596e896211e3617f0f31ccc3"><td class="memItemLeft" align="right" valign="top"><a id="aecbc728f596e896211e3617f0f31ccc3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getVerticies</b> () const -&gt; PtrVector&lt; <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &gt;</td></tr>
<tr class="separator:aecbc728f596e896211e3617f0f31ccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192fbdb08df36286ef86885e296f6938"><td class="memItemLeft" align="right" valign="top"><a id="a192fbdb08df36286ef86885e296f6938"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getAddr</b> () const -&gt; const <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> *</td></tr>
<tr class="separator:a192fbdb08df36286ef86885e296f6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40260412afed86308fc66c00669cfdbc"><td class="memItemLeft" align="right" valign="top"><a id="a40260412afed86308fc66c00669cfdbc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getAddr</b> () -&gt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> *</td></tr>
<tr class="separator:a40260412afed86308fc66c00669cfdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ff993ec4c1350a2df38eeebd9bd2cd"><td class="memItemLeft" align="right" valign="top"><a id="a97ff993ec4c1350a2df38eeebd9bd2cd"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (size_t i) -&gt; <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;</td></tr>
<tr class="separator:a97ff993ec4c1350a2df38eeebd9bd2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc037d1844298f7fd3ddd4a31efed6f0"><td class="memItemLeft" align="right" valign="top"><a id="adc037d1844298f7fd3ddd4a31efed6f0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (size_t i) const -&gt; const <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;</td></tr>
<tr class="separator:adc037d1844298f7fd3ddd4a31efed6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e89b1ae01df449cae1d2332028917"><td class="memItemLeft" align="right" valign="top"><a id="a0a6e89b1ae01df449cae1d2332028917"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getNodes</b> () -&gt; MutPtrVector&lt; <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &gt;</td></tr>
<tr class="separator:a0a6e89b1ae01df449cae1d2332028917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab011b6210d6d5a7877f53d57c92ba357"><td class="memItemLeft" align="right" valign="top"><a id="ab011b6210d6d5a7877f53d57c92ba357"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getEdges</b> () -&gt; MutPtrVector&lt; <a class="el" href="classpoly_1_1poly_1_1Dependence.html">Dependence</a> &gt;</td></tr>
<tr class="separator:ab011b6210d6d5a7877f53d57c92ba357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b4b6a757cf2abb980a5926e3f3fc12"><td class="memItemLeft" align="right" valign="top"><a id="a19b4b6a757cf2abb980a5926e3f3fc12"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>numNodes</b> () const -&gt; size_t</td></tr>
<tr class="separator:a19b4b6a757cf2abb980a5926e3f3fc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac645b101cbf0fba41941483497c94e23"><td class="memItemLeft" align="right" valign="top"><a id="ac645b101cbf0fba41941483497c94e23"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>numEdges</b> () const -&gt; size_t</td></tr>
<tr class="separator:ac645b101cbf0fba41941483497c94e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea5a98e52e5095d3b98e826c6cc4572"><td class="memItemLeft" align="right" valign="top"><a id="a4ea5a98e52e5095d3b98e826c6cc4572"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>numMemoryAccesses</b> () const -&gt; size_t</td></tr>
<tr class="separator:a4ea5a98e52e5095d3b98e826c6cc4572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862dac7cb517553d02bdfee244594eb2"><td class="memItemLeft" align="right" valign="top"><a id="a862dac7cb517553d02bdfee244594eb2"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>outNeighbors</b> (size_t idx) -&gt; <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1OutNeighbors.html">OutNeighbors</a></td></tr>
<tr class="separator:a862dac7cb517553d02bdfee244594eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2fcbc44fcbc17217b1f6062fe87dc8"><td class="memItemLeft" align="right" valign="top"><a id="aea2fcbc44fcbc17217b1f6062fe87dc8"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>calcMaxDepth</b> () const -&gt; size_t</td></tr>
<tr class="separator:aea2fcbc44fcbc17217b1f6062fe87dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891243bf6176d4d63d16190b05467cb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#a891243bf6176d4d63d16190b05467cb3">addEdge</a> (NotNull&lt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> &gt; mai, NotNull&lt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> &gt; maj)</td></tr>
<tr class="separator:a891243bf6176d4d63d16190b05467cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163bf4e024072759f9ab071250e6c2f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#a163bf4e024072759f9ab071250e6c2f6">fillEdges</a> ()</td></tr>
<tr class="separator:a163bf4e024072759f9ab071250e6c2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1f79ec8b905566d7d33624cf894c2d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#a7e1f79ec8b905566d7d33624cf894c2d">searchValueForStores</a> (<a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node, llvm::User *user, unsigned nodeIdx) -&gt; bool</td></tr>
<tr class="separator:a7e1f79ec8b905566d7d33624cf894c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe989920bab97ff1204809fa5852dcae"><td class="memItemLeft" align="right" valign="top"><a id="abe989920bab97ff1204809fa5852dcae"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>duplicateLoad</b> (NotNull&lt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> &gt; load, unsigned &amp;memId) -&gt; NotNull&lt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> &gt;</td></tr>
<tr class="separator:abe989920bab97ff1204809fa5852dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd0aa226033b3181074068581ae8136"><td class="memItemLeft" align="right" valign="top"><a id="a6fd0aa226033b3181074068581ae8136"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkUserForLoads</b> (<a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node, llvm::User *user, unsigned nodeIdx)</td></tr>
<tr class="separator:a6fd0aa226033b3181074068581ae8136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9fa70fb79aaf77a8cb7f5c471d2439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#aad9fa70fb79aaf77a8cb7f5c471d2439">searchOperandsForLoads</a> (<a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node, llvm::User *u, unsigned nodeIdx)</td></tr>
<tr class="separator:aad9fa70fb79aaf77a8cb7f5c471d2439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dec0a4aeb9d5bed2fa350cea301fc3"><td class="memItemLeft" align="right" valign="top"><a id="a78dec0a4aeb9d5bed2fa350cea301fc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connect</b> (unsigned inIndex, unsigned outIndex)</td></tr>
<tr class="separator:a78dec0a4aeb9d5bed2fa350cea301fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dffd3e3ecda3bebe7aeee8244b693f"><td class="memItemLeft" align="right" valign="top"><a id="a94dffd3e3ecda3bebe7aeee8244b693f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>calcNumStores</b> () const -&gt; size_t</td></tr>
<tr class="separator:a94dffd3e3ecda3bebe7aeee8244b693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671c0c137bd23bddb0fa10ba0c370937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#a671c0c137bd23bddb0fa10ba0c370937">connectGraph</a> ()</td></tr>
<tr class="separator:a671c0c137bd23bddb0fa10ba0c370937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa180b3b3cd239709bded6626f4148"><td class="memItemLeft" align="right" valign="top"><a id="aa6fa180b3b3cd239709bded6626f4148"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildGraph</b> ()</td></tr>
<tr class="separator:aa6fa180b3b3cd239709bded6626f4148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb6683d21c5a70a6e8372e0a549414"><td class="memItemLeft" align="right" valign="top"><a id="a6fbb6683d21c5a70a6e8372e0a549414"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>fullGraph</b> () -&gt; <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:a6fbb6683d21c5a70a6e8372e0a549414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a9700221372abd93c8668f51ead01e"><td class="memItemLeft" align="right" valign="top"><a id="a22a9700221372abd93c8668f51ead01e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optOrth</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> g) -&gt; std::optional&lt; BitSet &gt;</td></tr>
<tr class="separator:a22a9700221372abd93c8668f51ead01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c3a0da84f7686e108f3ea46da608b"><td class="memItemLeft" align="right" valign="top"><a id="aa73c3a0da84f7686e108f3ea46da608b"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>addMemory</b> (NotNull&lt; <a class="el" href="classArrayIndex.html">ArrayIndex</a> &gt; m)</td></tr>
<tr class="separator:aa73c3a0da84f7686e108f3ea46da608b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833dfe7e90f5ceaacf731a43a0f843c8"><td class="memItemLeft" align="right" valign="top"><a id="a833dfe7e90f5ceaacf731a43a0f843c8"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>addMemory</b> (<a class="el" href="structMemoryAccess.html">MemoryAccess</a> *m)</td></tr>
<tr class="separator:a833dfe7e90f5ceaacf731a43a0f843c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9a20e499f31244b80616fdba4e3a2a"><td class="memItemLeft" align="right" valign="top"><a id="a7c9a20e499f31244b80616fdba4e3a2a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node, size_t d) const -&gt; bool</td></tr>
<tr class="separator:a7c9a20e499f31244b80616fdba4e3a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b9c8557bd647e80ae9c9ca2e6330f1"><td class="memItemLeft" align="right" valign="top"><a id="a26b9c8557bd647e80ae9c9ca2e6330f1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node) const -&gt; bool</td></tr>
<tr class="separator:a26b9c8557bd647e80ae9c9ca2e6330f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dea247e1fa0e1ed5f9dc4624f4d0c1"><td class="memItemLeft" align="right" valign="top"><a id="aa4dea247e1fa0e1ed5f9dc4624f4d0c1"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>setScheduleMemoryOffsets</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d)</td></tr>
<tr class="separator:aa4dea247e1fa0e1ed5f9dc4624f4d0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2052b0bcfc84ed5464d7d534cc7d7e"><td class="memItemLeft" align="right" valign="top"><a id="adc2052b0bcfc84ed5464d7d534cc7d7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validateEdges</b> ()</td></tr>
<tr class="separator:adc2052b0bcfc84ed5464d7d534cc7d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29507d94d91a37eede5079b6190c34e2"><td class="memItemLeft" align="right" valign="top"><a id="a29507d94d91a37eede5079b6190c34e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shiftOmega</b> (<a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node)</td></tr>
<tr class="separator:a29507d94d91a37eede5079b6190c34e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2719203c556fe0e9a9c328e625e4eaeb"><td class="memItemLeft" align="right" valign="top"><a id="a2719203c556fe0e9a9c328e625e4eaeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shiftOmegas</b> ()</td></tr>
<tr class="separator:a2719203c556fe0e9a9c328e625e4eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec9d04dda8156678ce7e08b2bb8c385"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#a5ec9d04dda8156678ce7e08b2bb8c385">instantiateOmniSimplex</a> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d, bool satisfyDeps) -&gt; std::unique_ptr&lt; Simplex &gt;</td></tr>
<tr class="separator:a5ec9d04dda8156678ce7e08b2bb8c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf7c5e3801ee6c1b4a9f86dc44ae8f"><td class="memItemLeft" align="right" valign="top"><a id="a1faf7c5e3801ee6c1b4a9f86dc44ae8f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>solveGraph</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, bool satisfyDeps) -&gt; std::optional&lt; BitSet &gt;</td></tr>
<tr class="separator:a1faf7c5e3801ee6c1b4a9f86dc44ae8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585a9b512035279cf3acac699377f921"><td class="memItemLeft" align="right" valign="top"><a id="a585a9b512035279cf3acac699377f921"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>checkEmptySatEdges</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth) -&gt; BitSet</td></tr>
<tr class="separator:a585a9b512035279cf3acac699377f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac483ce1d04158a34a12baf9886286c71"><td class="memItemLeft" align="right" valign="top"><a id="ac483ce1d04158a34a12baf9886286c71"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>deactivateSatisfiedEdges</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, Simplex::Solution sol) -&gt; BitSet</td></tr>
<tr class="separator:ac483ce1d04158a34a12baf9886286c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c32342b68c1e984f62193cf2a2d84cc"><td class="memItemLeft" align="right" valign="top"><a id="a3c32342b68c1e984f62193cf2a2d84cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateSchedules</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, Simplex::Solution sol)</td></tr>
<tr class="separator:a3c32342b68c1e984f62193cf2a2d84cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281673de5f93c578ad7b3b5435963727"><td class="memItemLeft" align="right" valign="top"><a id="a281673de5f93c578ad7b3b5435963727"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addIndependentSolutionConstraints</b> (NotNull&lt; Simplex &gt; omniSimplex, const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d)</td></tr>
<tr class="separator:a281673de5f93c578ad7b3b5435963727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9316b6236c26710ce969f0d529513"><td class="memItemLeft" align="right" valign="top"><a id="a05f9316b6236c26710ce969f0d529513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSchedulesIndependent</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth)</td></tr>
<tr class="separator:a05f9316b6236c26710ce969f0d529513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b501377bfce47a2d34ed444a70a7c6d"><td class="memItemLeft" align="right" valign="top"><a id="a7b501377bfce47a2d34ed444a70a7c6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetPhiOffsets</b> ()</td></tr>
<tr class="separator:a7b501377bfce47a2d34ed444a70a7c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8808f9c2ab86877a017f3ee20d5eed1"><td class="memItemLeft" align="right" valign="top"><a id="af8808f9c2ab86877a017f3ee20d5eed1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classpoly_1_1poly_1_1Dependence.html">Dependence</a> &amp;e, size_t d) -&gt; bool</td></tr>
<tr class="separator:af8808f9c2ab86877a017f3ee20d5eed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea05191574bde81ca5a094cde9d066"><td class="memItemLeft" align="right" valign="top"><a id="a49ea05191574bde81ca5a094cde9d066"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>canFuse</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g0, <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g1, size_t d) -&gt; bool</td></tr>
<tr class="separator:a49ea05191574bde81ca5a094cde9d066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8471877a100c1e8ea122a2b684e0983"><td class="memItemLeft" align="right" valign="top"><a id="af8471877a100c1e8ea122a2b684e0983"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>breakGraph</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> g, size_t d) -&gt; std::optional&lt; BitSet &gt;</td></tr>
<tr class="separator:af8471877a100c1e8ea122a2b684e0983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dacd7819562c466365d93eac1df0aaa"><td class="memTemplParams" colspan="2"><a id="a6dacd7819562c466365d93eac1df0aaa"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:a6dacd7819562c466365d93eac1df0aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_edge</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d, F &amp;&amp;f)</td></tr>
<tr class="separator:a6dacd7819562c466365d93eac1df0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebe836eaed54883362cd3bdce5c9ca5"><td class="memItemLeft" align="right" valign="top"><a id="acebe836eaed54883362cd3bdce5c9ca5"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>countAuxParamsAndConstraints</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d)</td></tr>
<tr class="separator:acebe836eaed54883362cd3bdce5c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8ed8953d5bb487ef57d7b86c5c1149"><td class="memItemLeft" align="right" valign="top"><a id="a8c8ed8953d5bb487ef57d7b86c5c1149"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>countAuxAndStash</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d)</td></tr>
<tr class="separator:a8c8ed8953d5bb487ef57d7b86c5c1149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c35f57de0f92f78147bfa5c244d80a"><td class="memItemLeft" align="right" valign="top"><a id="a43c35f57de0f92f78147bfa5c244d80a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optimizeSatDep</b> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> g, size_t d, size_t maxDepth, BitSet depSatLevel, BitSet activeEdges) -&gt; BitSet</td></tr>
<tr class="separator:a43c35f57de0f92f78147bfa5c244d80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab93bd6f5f56f93c6c693d69317ee6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html#a1ab93bd6f5f56f93c6c693d69317ee6c">optimize</a> (<a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> g, size_t d, size_t maxDepth) -&gt; std::optional&lt; BitSet &gt;</td></tr>
<tr class="separator:a1ab93bd6f5f56f93c6c693d69317ee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8f267241839ee8b926beba0c3b0a3c"><td class="memItemLeft" align="right" valign="top"><a id="aea8f267241839ee8b926beba0c3b0a3c"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> () -&gt; std::optional&lt; BitSet &gt;</td></tr>
<tr class="separator:aea8f267241839ee8b926beba0c3b0a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecba575077b42a94e19581ec61f3c769"><td class="memItemLeft" align="right" valign="top"><a id="aecba575077b42a94e19581ec61f3c769"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>summarizeMemoryAccesses</b> (llvm::raw_ostream &amp;os) const -&gt; llvm::raw_ostream &amp;</td></tr>
<tr class="separator:aecba575077b42a94e19581ec61f3c769"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:add096a974f083b5532bb3b8a0d4da603"><td class="memItemLeft" align="right" valign="top"><a id="add096a974f083b5532bb3b8a0d4da603"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>connects</b> (const <a class="el" href="classpoly_1_1poly_1_1Dependence.html">Dependence</a> &amp;e, <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g0, <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g1) -&gt; bool</td></tr>
<tr class="separator:add096a974f083b5532bb3b8a0d4da603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dd37544d5cef4fb91cd3793912d4a6"><td class="memItemLeft" align="right" valign="top"><a id="ad3dd37544d5cef4fb91cd3793912d4a6"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getOverlapIndex</b> (const <a class="el" href="classpoly_1_1poly_1_1Dependence.html">Dependence</a> &amp;edge) -&gt; Optional&lt; size_t &gt;</td></tr>
<tr class="separator:ad3dd37544d5cef4fb91cd3793912d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef4ace8dc6af07147d3460dea129f32"><td class="memItemLeft" align="right" valign="top"><a id="acef4ace8dc6af07147d3460dea129f32"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>anyActive</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const BitSet &amp;b) -&gt; bool</td></tr>
<tr class="separator:acef4ace8dc6af07147d3460dea129f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5450dada9d2ccb4679d06131853ec7"><td class="memItemLeft" align="right" valign="top"><a id="a8d5450dada9d2ccb4679d06131853ec7"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>anyActive</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d, const BitSet &amp;b) -&gt; bool</td></tr>
<tr class="separator:a8d5450dada9d2ccb4679d06131853ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3826bf5642787f824e48ab06c5384a2"><td class="memItemLeft" align="right" valign="top"><a id="ac3826bf5642787f824e48ab06c5384a2"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="structMemoryAccess.html">MemoryAccess</a> *mem) -&gt; bool</td></tr>
<tr class="separator:ac3826bf5642787f824e48ab06c5384a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8842fc8b16eb4e3a17d45d2a4d14c0"><td class="memItemLeft" align="right" valign="top"><a id="a3c8842fc8b16eb4e3a17d45d2a4d14c0"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="structMemoryAccess.html">MemoryAccess</a> *mem, size_t d) -&gt; bool</td></tr>
<tr class="separator:a3c8842fc8b16eb4e3a17d45d2a4d14c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba445e1732c9a36c9ffb61c9f70efa7"><td class="memItemLeft" align="right" valign="top"><a id="aaba445e1732c9a36c9ffb61c9f70efa7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>updateConstraints</b> (MutPtrMatrix&lt; int64_t &gt; C, const <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node, PtrMatrix&lt; int64_t &gt; sat, PtrMatrix&lt; int64_t &gt; bnd, size_t d, Row c, Row cc, Row ccc, Col p)</td></tr>
<tr class="separator:aaba445e1732c9a36c9ffb61c9f70efa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6dbf09d58f83349b556f2dfe998054"><td class="memItemLeft" align="right" valign="top"><a id="aaf6dbf09d58f83349b556f2dfe998054"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setDepFreeSchedule</b> (PtrVector&lt; <a class="el" href="structMemoryAccess.html">MemoryAccess</a> * &gt; mem, <a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;node, size_t depth)</td></tr>
<tr class="separator:aaf6dbf09d58f83349b556f2dfe998054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410c4d674cbfcb223be1fa1307eb0069"><td class="memItemLeft" align="right" valign="top"><a id="a410c4d674cbfcb223be1fa1307eb0069"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>lexSign</b> (PtrVector&lt; int64_t &gt; x) -&gt; int64_t</td></tr>
<tr class="separator:a410c4d674cbfcb223be1fa1307eb0069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb18b1896b44af47be1f53b79cf97f89"><td class="memItemLeft" align="right" valign="top"><a id="abb18b1896b44af47be1f53b79cf97f89"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMask</b> (const AbstractVector auto &amp;x) -&gt; uint64_t</td></tr>
<tr class="separator:abb18b1896b44af47be1f53b79cf97f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818d0e6d30cf9e09f80a50f159bf7da0"><td class="memItemLeft" align="right" valign="top"><a id="a818d0e6d30cf9e09f80a50f159bf7da0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMasks</b> (Vector&lt; uint64_t &gt; &amp;masks, const AbstractMatrix auto &amp;A)</td></tr>
<tr class="separator:a818d0e6d30cf9e09f80a50f159bf7da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb77b9b72a13c62de0138658f5210c45"><td class="memItemLeft" align="right" valign="top"><a id="aeb77b9b72a13c62de0138658f5210c45"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMasks</b> (const AbstractMatrix auto &amp;A) -&gt; Vector&lt; uint64_t &gt;</td></tr>
<tr class="separator:aeb77b9b72a13c62de0138658f5210c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448bdef89c23238b7b303691215b50b"><td class="memItemLeft" align="right" valign="top"><a id="a3448bdef89c23238b7b303691215b50b"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMask</b> (const AbstractMatrix auto A) -&gt; uint64_t</td></tr>
<tr class="separator:a3448bdef89c23238b7b303691215b50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32135068377aa575623a58b138cb6be"><td class="memItemLeft" align="right" valign="top"><a id="aa32135068377aa575623a58b138cb6be"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>numParams</b> (const <a class="el" href="classpoly_1_1poly_1_1Dependence.html">Dependence</a> &amp;edge) -&gt; math::SVector&lt; size_t, 4 &gt;</td></tr>
<tr class="separator:aa32135068377aa575623a58b138cb6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5d60a366db975c30da3dea7b9d93f597"><td class="memItemLeft" align="right" valign="top"><a id="a5d60a366db975c30da3dea7b9d93f597"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classpoly_1_1lp_1_1LinearProgramLoopBlock.html">LinearProgramLoopBlock</a> &amp;lblock) -&gt; llvm::raw_ostream &amp;</td></tr>
<tr class="separator:a5d60a366db975c30da3dea7b9d93f597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A loop block is a block of the program that may include multiple loops. These loops are either all executed (note iteration count may be 0, or loops may be in rotated form and the guard prevents execution; this is okay and counts as executed for our purposes here ), or none of them are. That is, the LoopBlock does not contain divergent control flow, or guards unrelated to loop bounds. The loops within a LoopBlock are optimized together, so we can consider optimizations such as reordering or fusing them together as a set.</p>
<p>Initially, the <code>LoopBlock</code> is initialized as a set of <code>Read</code> and <code>Write</code>s, without any dependence polyhedra. Then, it builds <code>DependencePolyhedra</code>. These can be used to construct an ILP.</p>
<p>That is: fields that must be provided/filled:</p><ul>
<li>refs</li>
<li>memory</li>
<li>userToMemory fields it self-initializes:</li>
</ul>
<p>NOTE: w/ respect to index linearization (e.g., going from Cartesian indexing to linear indexing), the current behavior will be to fully delinearize as a preprocessing step. Linear indexing may be used later as an optimization. This means that not only do we want to delinearize for (n = 0; n &lt; N; ++n){ for (m = 0; m &lt; M; ++m){ C(m + n*M) } } we would also want to delinearize for (i = 0; i &lt; M*N; ++i){ C(i) } into for (n = 0; n &lt; N; ++n){ for (m = 0; m &lt; M; ++m){ C(m, n) } } and then relinearize as an optimization later. Then we can compare fully delinearized loop accesses. Should be in same block: s = 0 for (i = eachindex(x)){ s += x[i]; // Omega = [0, _, 0] } m = s / length(x); // Omega = [1] for (i = eachindex(y)){ f(m, ...); // Omega = [2, _, 0] } </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a891243bf6176d4d63d16190b05467cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891243bf6176d4d63d16190b05467cb3">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void poly::lp::LinearProgramLoopBlock::addEdge </td>
          <td>(</td>
          <td class="paramtype">NotNull&lt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> &gt;&#160;</td>
          <td class="paramname"><em>mai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NotNull&lt; <a class="el" href="classpoly_1_1IR_1_1Addr.html">Addr</a> &gt;&#160;</td>
          <td class="paramname"><em>maj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NOTE: this relies on two important assumptions:</p><ol type="1">
<li>Code has been fully delinearized, so that axes all match (this means that even C[i], 0&lt;=i&lt;M*N -&gt; C[m*M*n]) (TODO: what if we have C[n+N*m] and C[m+M*n]???) (this of course means we have to see other uses in deciding whether to expand <code>C[i]</code>, and what to expand it into.)</li>
<li>Reduction targets have been orthogonalized, so that the number of axes reflects the number of loops they depend on. if we have for (i = I, j = J, m = M, n = N) { C(m,n) = foo(C(m,n), ...) } then we have dependencies that the load C(m,n) [ i = x, j = y ] happens after the store C(m,n) [ i = x-1, j = y], and happens after the store C(m,n) [ i = x, j = y-1] and that the store C(m,n) [ i = x, j = y ] happens after the load C(m,n) [ i = x-1, j = y], and happens after the load C(m,n) [ i = x, j = y-1] </li>
</ol>

</div>
</div>
<a id="a671c0c137bd23bddb0fa10ba0c370937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671c0c137bd23bddb0fa10ba0c370937">&#9670;&nbsp;</a></span>connectGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void poly::lp::LinearProgramLoopBlock::connectGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When connecting a graph, we draw direct connections between stores and loads loads may be duplicated across stores to allow for greater reordering flexibility (which should generally reduce the ultimate amount of loads executed in the eventual generated code) </p>

</div>
</div>
<a id="a163bf4e024072759f9ab071250e6c2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163bf4e024072759f9ab071250e6c2f6">&#9670;&nbsp;</a></span>fillEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void poly::lp::LinearProgramLoopBlock::fillEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>fills all the edges between memory accesses, checking for dependencies. </p>

</div>
</div>
<a id="a5ec9d04dda8156678ce7e08b2bb8c385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec9d04dda8156678ce7e08b2bb8c385">&#9670;&nbsp;</a></span>instantiateOmniSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto poly::lp::LinearProgramLoopBlock::instantiateOmniSimplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>satisfyDeps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::unique_ptr&lt;Simplex&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For now, we instantiate a dense simplex specifying the full problem.</p>
<p>Eventually, the plan is to generally avoid instantiating the omni-simplex first, we solve individual problems</p>
<p>The order of variables in the simplex is: C, lambdas, slack, omegas, Phis, w, u where C: constraints, rest of matrix * variables == C lambdas: farkas multipliers slack: slack variables from independent phi solution constraints omegas: scheduling offsets Phis: scheduling rotations w: bounding offsets, independent of symbolic variables u: bounding offsets, dependent on symbolic variables </p>

</div>
</div>
<a id="a1ab93bd6f5f56f93c6c693d69317ee6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab93bd6f5f56f93c6c693d69317ee6c">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto poly::lp::LinearProgramLoopBlock::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoly_1_1lp_1_1LinearProgramLoopBlock_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;BitSet&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>optimize at depth <code>d</code> receives graph by value, so that it is not invalidated when recursing </p>

</div>
</div>
<a id="aad9fa70fb79aaf77a8cb7f5c471d2439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9fa70fb79aaf77a8cb7f5c471d2439">&#9670;&nbsp;</a></span>searchOperandsForLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void poly::lp::LinearProgramLoopBlock::searchOperandsForLoads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::User *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We search uses of user <code>u</code> for any stores so that we can assign the use and the store the same schedule. This is done because it is assumed the data is held in registers (or, if things go wrong, spilled to the stack) in between a load and a store. A complication is that LLVM IR can be messy, e.g. we may have x = load a y = call foo(x) store y, b z = call bar(y) store z, c here, we might lock all three operations together. However, this limits reordering opportunities; we thus want to insert a new load instruction so that we have: x = load a y = call foo(x) store y, b y.reload = load b z = call bar(y.reload) store z, c and we create a new edge from <code>store y, b</code> to <code>load b</code>. We're going to also build up the <code>Node</code> graph, this is to avoid duplicating any logic or needing to traverse the object graph an extra time as we go. </p>

</div>
</div>
<a id="a7e1f79ec8b905566d7d33624cf894c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1f79ec8b905566d7d33624cf894c2d">&#9670;&nbsp;</a></span>searchValueForStores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto poly::lp::LinearProgramLoopBlock::searchValueForStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpoly_1_1lp_1_1ScheduledNode.html">ScheduledNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::User *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>used in searchOperandsForLoads if an operand is stored, we can reload it. This will insert a new store memory access.</p>
<p>If an instruction was stored somewhere, we don't keep searching for place it was loaded, and instead add a reload. </p>

</div>
</div>
<a id="aeb144277abaf1e1110ab128ff16802e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb144277abaf1e1110ab128ff16802e3">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void poly::lp::LinearProgramLoopBlock::truncate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numToDrop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>L is the inner-most loop getting dropped, i.e. it is the level at which the TreeResult rejected </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/LinearProgramming/<a class="el" href="LoopBlock_8hpp_source.html">LoopBlock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
