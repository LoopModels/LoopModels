<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LoopModels: TurboLoopPass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LoopModels
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classTurboLoopPass-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TurboLoopPass Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TurboLoopPass:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTurboLoopPass.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af9807d01afcf6c6e021e6e72d5cae415"><td class="memItemLeft" align="right" valign="top"><a id="af9807d01afcf6c6e021e6e72d5cae415"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> (llvm::Function &amp;F, llvm::FunctionAnalysisManager &amp;AM) -&gt; llvm::PreservedAnalyses</td></tr>
<tr class="separator:af9807d01afcf6c6e021e6e72d5cae415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53327dd0a31c2543787ddf46f169261"><td class="memItemLeft" align="right" valign="top"><a id="af53327dd0a31c2543787ddf46f169261"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TurboLoopPass</b> (const <a class="el" href="classTurboLoopPass.html">TurboLoopPass</a> &amp;)=delete</td></tr>
<tr class="separator:af53327dd0a31c2543787ddf46f169261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ea157f74ea8ad9e824a9d3bccb9255"><td class="memItemLeft" align="right" valign="top"><a id="a68ea157f74ea8ad9e824a9d3bccb9255"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TurboLoopPass</b> (<a class="el" href="classTurboLoopPass.html">TurboLoopPass</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a68ea157f74ea8ad9e824a9d3bccb9255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d15982d3d7c2d1918da31c454a2f10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTurboLoopPass.html#a61d15982d3d7c2d1918da31c454a2f10">initializeLoopForest</a> ()</td></tr>
<tr class="separator:a61d15982d3d7c2d1918da31c454a2f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800e00e8d5eac3200e6bc027d78a89a0"><td class="memItemLeft" align="right" valign="top"><a id="a800e00e8d5eac3200e6bc027d78a89a0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>initLoopTree</b> (<a class="el" href="classLoop.html">Loop</a> *pForest, llvm::Loop *L, llvm::BasicBlock *H, llvm::BasicBlock *E, <a class="el" href="structNoWrapRewriter.html">NoWrapRewriter</a> &amp;nwr) -&gt; <a class="el" href="classLoop.html">Loop</a> *</td></tr>
<tr class="separator:a800e00e8d5eac3200e6bc027d78a89a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab43de6861ce48b2dcb781d235594c54"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTurboLoopPass.html#aab43de6861ce48b2dcb781d235594c54">runOnLoop</a> (llvm::Loop *L, llvm::ArrayRef&lt; llvm::Loop * &gt; subLoops, llvm::BasicBlock *H, llvm::BasicBlock *E, Vector&lt; unsigned &gt; &amp;omegas, <a class="el" href="structNoWrapRewriter.html">NoWrapRewriter</a> &amp;nwr) -&gt; <a class="el" href="classLoop.html">Loop</a> *</td></tr>
<tr class="separator:aab43de6861ce48b2dcb781d235594c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a05da9e1188d7064a4a9a934e37700e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTurboLoopPass.html#a8a05da9e1188d7064a4a9a934e37700e">pushLoopTree</a> (llvm::Loop *L, llvm::ArrayRef&lt; llvm::Loop * &gt; subLoops, llvm::BasicBlock *H, llvm::BasicBlock *E, <a class="el" href="structNoWrapRewriter.html">NoWrapRewriter</a> &amp;nwr) -&gt; size_t</td></tr>
<tr class="separator:a8a05da9e1188d7064a4a9a934e37700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584c251388b3bb0d01b707a4877d6524"><td class="memItemLeft" align="right" valign="top"><a id="a584c251388b3bb0d01b707a4877d6524"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (llvm::SmallVector&lt; <a class="el" href="classNotNull.html">NotNull</a>&lt; <a class="el" href="structLoopTree.html">LoopTree</a> &gt;&gt; &amp;branches, llvm::SmallVector&lt; <a class="el" href="structPredicate_1_1Map.html">Predicate::Map</a> &gt; &amp;branchBlocks, llvm::BasicBlock *BB, llvm::Loop *L)</td></tr>
<tr class="separator:a584c251388b3bb0d01b707a4877d6524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a65020e14d0d99344a6521a373bb0"><td class="memItemLeft" align="right" valign="top"><a id="a5c4a65020e14d0d99344a6521a373bb0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>isLoopPreHeader</b> (const llvm::BasicBlock *BB) const -&gt; bool</td></tr>
<tr class="separator:a5c4a65020e14d0d99344a6521a373bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5eccc351f6f22cf74a5ffcd3b433b0"><td class="memItemLeft" align="right" valign="top"><a id="a5c5eccc351f6f22cf74a5ffcd3b433b0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>fillAffineIndices</b> (MutPtrVector&lt; int64_t &gt; v, int64_t *coffset, Vector&lt; int64_t &gt; &amp;offsets, llvm::SmallVector&lt; const llvm::SCEV *, 3 &gt; &amp;symbolicOffsets, const llvm::SCEV *S, int64_t mlt, size_t numPeeled) -&gt; uint64_t</td></tr>
<tr class="separator:a5c5eccc351f6f22cf74a5ffcd3b433b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f1902ec4c94e489fac2e5418cb9479"><td class="memItemLeft" align="right" valign="top"><a id="a94f1902ec4c94e489fac2e5418cb9479"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>arrayRef</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, llvm::Instruction *ptr, const llvm::SCEV *elSize, llvm::Instruction *loadOrStore, MutPtrVector&lt; unsigned &gt; omegas) -&gt; bool</td></tr>
<tr class="separator:a94f1902ec4c94e489fac2e5418cb9479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80eb6e4b8e5ee251b4537aa953e8dfbe"><td class="memItemLeft" align="right" valign="top"><a id="a80eb6e4b8e5ee251b4537aa953e8dfbe"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getLoopTree</b> (llvm::Loop *L) -&gt; <a class="el" href="structLoopTree.html">LoopTree</a> *</td></tr>
<tr class="separator:a80eb6e4b8e5ee251b4537aa953e8dfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac172bbb2f638d50efc37867749d5f11c"><td class="memItemLeft" align="right" valign="top"><a id="ac172bbb2f638d50efc37867749d5f11c"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>addRef</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, LoadOrStoreInst auto *J, Vector&lt; unsigned &gt; &amp;omega) -&gt; bool</td></tr>
<tr class="separator:ac172bbb2f638d50efc37867749d5f11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c0a003ac14b71db598977cf599db0c"><td class="memItemLeft" align="right" valign="top"><a id="af8c0a003ac14b71db598977cf599db0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseBB</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, llvm::BasicBlock *BB, Vector&lt; unsigned &gt; &amp;omega)</td></tr>
<tr class="separator:af8c0a003ac14b71db598977cf599db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c368857149b175ea3d50d2086a68b72"><td class="memItemLeft" align="right" valign="top"><a id="a8c368857149b175ea3d50d2086a68b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, <a class="el" href="structPredicate_1_1Map.html">Predicate::Map</a> &amp;map, Vector&lt; unsigned &gt; &amp;omega, <a class="el" href="structaset.html">aset</a>&lt; llvm::BasicBlock * &gt; &amp;visited, llvm::BasicBlock *BB)</td></tr>
<tr class="separator:a8c368857149b175ea3d50d2086a68b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa9639f17ccb0a13eb71079b6e13919"><td class="memItemLeft" align="right" valign="top"><a id="a4fa9639f17ccb0a13eb71079b6e13919"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseBBMap</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, <a class="el" href="structPredicate_1_1Map.html">Predicate::Map</a> &amp;map, Vector&lt; unsigned &gt; &amp;omega)</td></tr>
<tr class="separator:a4fa9639f17ccb0a13eb71079b6e13919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00211a93f815ef8a1c681882876f165"><td class="memItemLeft" align="right" valign="top"><a id="aa00211a93f815ef8a1c681882876f165"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseLoop</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, Vector&lt; unsigned &gt; &amp;omega)</td></tr>
<tr class="separator:aa00211a93f815ef8a1c681882876f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb4e3f628a44a345a9546092e2c17c3"><td class="memItemLeft" align="right" valign="top"><a id="aafb4e3f628a44a345a9546092e2c17c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseNest</b> ()</td></tr>
<tr class="separator:aafb4e3f628a44a345a9546092e2c17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3474dc5831047f41439c141968197010"><td class="memItemLeft" align="right" valign="top"><a id="a3474dc5831047f41439c141968197010"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>peelOuterLoops</b> (llvm::Loop *L, size_t numToPeel)</td></tr>
<tr class="separator:a3474dc5831047f41439c141968197010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a1489d1bbc605af755c0435f178fd8"><td class="memItemLeft" align="right" valign="top"><a id="aa5a1489d1bbc605af755c0435f178fd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>peelOuterLoops</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;LT, size_t numToPeel)</td></tr>
<tr class="separator:aa5a1489d1bbc605af755c0435f178fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1a38fdf9dfe398a93ca2683729c882"><td class="memItemLeft" align="right" valign="top"><a id="a1e1a38fdf9dfe398a93ca2683729c882"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>conditionOnLoop</b> (llvm::Loop *L)</td></tr>
<tr class="separator:a1e1a38fdf9dfe398a93ca2683729c882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d534e0cbe573fcc201c9b0f65bc45dc"><td class="memItemLeft" align="right" valign="top"><a id="a0d534e0cbe573fcc201c9b0f65bc45dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>conditionOnLoop</b> (<a class="el" href="structLoopTree.html">LoopTree</a> *LT)</td></tr>
<tr class="separator:a0d534e0cbe573fcc201c9b0f65bc45dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae198a11c02e4fe5c24f9c0b65a3b80a6"><td class="memItemLeft" align="right" valign="top"><a id="ae198a11c02e4fe5c24f9c0b65a3b80a6"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>isLoopDependent</b> (llvm::Value *v) const -&gt; bool</td></tr>
<tr class="separator:ae198a11c02e4fe5c24f9c0b65a3b80a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86158dc4a0a190dfc6d3ef4cf8e52ea5"><td class="memItemLeft" align="right" valign="top"><a id="a86158dc4a0a190dfc6d3ef4cf8e52ea5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillLoopBlock</b> (<a class="el" href="structLoopTree.html">LoopTree</a> &amp;root)</td></tr>
<tr class="separator:a86158dc4a0a190dfc6d3ef4cf8e52ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefac38bb17ae02962634dd6579079038"><td class="memItemLeft" align="right" valign="top"><a id="aefac38bb17ae02962634dd6579079038"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remark</b> (const llvm::StringRef remarkName, llvm::Loop *L, const llvm::StringRef remarkMessage, llvm::Instruction *J=nullptr) const</td></tr>
<tr class="separator:aefac38bb17ae02962634dd6579079038"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acd87d766809eb24f3b2344d2624d584e"><td class="memItemLeft" align="right" valign="top"><a id="acd87d766809eb24f3b2344d2624d584e"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>containsPeeled</b> (const llvm::SCEV *Sc, size_t numPeeled) -&gt; bool</td></tr>
<tr class="separator:acd87d766809eb24f3b2344d2624d584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb013b38dda5774c526a10fcfe3058d"><td class="memItemLeft" align="right" valign="top"><a id="aeeb013b38dda5774c526a10fcfe3058d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>addSymbolic</b> (Vector&lt; int64_t &gt; &amp;offsets, llvm::SmallVector&lt; const llvm::SCEV *, 3 &gt; &amp;symbols, const llvm::SCEV *S, int64_t x=1)</td></tr>
<tr class="separator:aeeb013b38dda5774c526a10fcfe3058d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19e4f4cd2fcb6d7d18c7128667ede16"><td class="memItemLeft" align="right" valign="top"><a id="ac19e4f4cd2fcb6d7d18c7128667ede16"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>blackListAllDependentLoops</b> (const llvm::SCEV *S) -&gt; uint64_t</td></tr>
<tr class="separator:ac19e4f4cd2fcb6d7d18c7128667ede16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb696d6c05f9b16ca2f13da77a291bf3"><td class="memItemLeft" align="right" valign="top"><a id="aeb696d6c05f9b16ca2f13da77a291bf3"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>blackListAllDependentLoops</b> (const llvm::SCEV *S, size_t numPeeled) -&gt; uint64_t</td></tr>
<tr class="separator:aeb696d6c05f9b16ca2f13da77a291bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d40c1e27454c1e7e627f590cc4ae2a3"><td class="memItemLeft" align="right" valign="top"><a id="a7d40c1e27454c1e7e627f590cc4ae2a3"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>mayReadOrWriteMemory</b> (llvm::Value *v) -&gt; bool</td></tr>
<tr class="separator:a7d40c1e27454c1e7e627f590cc4ae2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61d15982d3d7c2d1918da31c454a2f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d15982d3d7c2d1918da31c454a2f10">&#9670;&nbsp;</a></span>initializeLoopForest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TurboLoopPass::initializeLoopForest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the process of building the LoopForest has the following steps:</p><ol type="1">
<li>build initial forest of trees</li>
<li>instantiate AffineLoopNests; any non-affine loops are pruned, and their inner loops added as new, separate forests.</li>
<li>Existing forests are searched for indirect control flow between successive loops. In all such cases, the loops at that level are split into separate forests. </li>
</ol>

</div>
</div>
<a id="a8a05da9e1188d7064a4a9a934e37700e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a05da9e1188d7064a4a9a934e37700e">&#9670;&nbsp;</a></span>pushLoopTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TurboLoopPass::pushLoopTree </td>
          <td>(</td>
          <td class="paramtype">llvm::Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Loop * &gt;&#160;</td>
          <td class="paramname"><em>subLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::BasicBlock *&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::BasicBlock *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNoWrapRewriter.html">NoWrapRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>nwr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>pushLoopTree</p>
<p>pushLoopTree pushes <code>llvm::Loop* L</code> into a <code><a class="el" href="structLoopTree.html">LoopTree</a></code> object if <code>L == nullptr</code>, then this represents a top level loop. If we fail at some level of the recursion, we push the tree we have successfully built into loopForests as its own loop forest. If we succeed, we push the tree into the parent tree.</p>
<p>To be successful, the following conditions need to be met:</p><ol type="1">
<li>We can represent that and all inner levels as an affine loop nest.</li>
<li>We can represent all indices as affine expressions.</li>
<li>We have a direct path between exits of one loop at a level and the header of the next.</li>
</ol>
<p>The arguments are:</p><ol type="1">
<li><code>llvm::SmallVectorImpl&lt;llvm::Loop *&gt; &amp;pForest</code>: the forest in which we are planting our tree.</li>
<li><code>llvm::Loop* loop</code>: the loop we are trying to plant.</li>
<li><code>llvm::SmallVector&lt;unsigned&gt; &amp;omega</code>: The current position of the parser, for recording in memory accesses.</li>
<li><code>llvm::ArrayRef&lt;llvm::Loop *&gt; subLoops</code>: the sub-loops of <code>L</code>; we don't access it directly via <code>L-&gt;getSubLoops</code> because we use <code>L==nullptr</code> to repesent the top level nest, in which case we get the sub-loops from the <code>llvm::LoopInfo*</code> object.</li>
<li><code>llvm::BasicBlock *H</code>: Header - we need a direct path from here to the first sub-loop's preheader</li>
<li><code>llvm::BasicBlock *E</code>: <a class="el" href="classExit.html">Exit</a> - we need a direct path from the last sub-loop's exit block to this. </li>
</ol>

</div>
</div>
<a id="aab43de6861ce48b2dcb781d235594c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab43de6861ce48b2dcb781d235594c54">&#9670;&nbsp;</a></span>runOnLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TurboLoopPass::runOnLoop </td>
          <td>(</td>
          <td class="paramtype">llvm::Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Loop * &gt;&#160;</td>
          <td class="paramname"><em>subLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::BasicBlock *&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::BasicBlock *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>omegas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNoWrapRewriter.html">NoWrapRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>nwr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classLoop.html">Loop</a> * </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>runOnLoop LLVM parsing: We try to produce our own internal IR from LLVM loops we parse the loop forest depth-first on each failure, we run the analysis on what we can. E.g. invalid -&gt; [A] valid -&gt; valid -&gt; [B] valid -&gt; valid -&gt; valid Here, we would run on [A] and [B] separately. valid -&gt; [A] valid -&gt; valid -&gt; valid -&gt; [B] valid -&gt; invalid Here, we would also run on [A] and [B] separately. We evaluate all branches before evaluating a node itself.</p>
<p><code>runOnLoop</code> returns <code>nullptr</code> arguments: 0. <code>llvm::Loop *L</code>: the loop we are currently processing, exterior to this</p><ol type="1">
<li><code>llvm::ArrayRef&lt;llvm::Loop *&gt; subLoops</code>: the sub-loops of <code>L</code>; we don't access it directly via <code>L-&gt;getSubLoops</code> because we use <code>L==nullptr</code> to repesent the top level nest, in which case we get the sub-loops from the <code>llvm::LoopInfo*</code> object.</li>
<li><code>llvm::BasicBlock *H</code>: Header - we need a direct path from here to the first sub-loop's preheader</li>
<li><code>llvm::BasicBlock *E</code>: <a class="el" href="classExit.html">Exit</a> - we need a direct path from the last sub-loop's exit block to this.</li>
<li><code>Vector&lt;unsigned&gt; &amp;omegas</code>: the current position within the loopnest </li>
</ol>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="TurboLoop_8hpp_source.html">TurboLoop.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
