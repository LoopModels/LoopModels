<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LoopModels: LinearProgramLoopBlock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LoopModels
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classLinearProgramLoopBlock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearProgramLoopBlock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="LoopBlock_8hpp_source.html">LoopBlock.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLinearProgramLoopBlock_1_1OutNeighbors.html">OutNeighbors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a69ee090aa815b3beadaaa0f677c63da2"><td class="memItemLeft" align="right" valign="top"><a id="a69ee090aa815b3beadaaa0f677c63da2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BitSet</b> = ::MemoryAccess::BitSet</td></tr>
<tr class="separator:a69ee090aa815b3beadaaa0f677c63da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3db13fb21d86096bef9e01c8d570ec73"><td class="memItemLeft" align="right" valign="top"><a id="a3db13fb21d86096bef9e01c8d570ec73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a3db13fb21d86096bef9e01c8d570ec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bd7f6660242af06777150a5a50b3c9"><td class="memItemLeft" align="right" valign="top"><a id="ab3bd7f6660242af06777150a5a50b3c9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>numVerticies</b> () const -&gt; size_t</td></tr>
<tr class="separator:ab3bd7f6660242af06777150a5a50b3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf28cb5f5bf47d5d00f2dd7fdf5feebd"><td class="memItemLeft" align="right" valign="top"><a id="adf28cb5f5bf47d5d00f2dd7fdf5feebd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>getVerticies</b> () -&gt; MutPtrVector&lt; <a class="el" href="structScheduledNode.html">ScheduledNode</a> &gt;</td></tr>
<tr class="separator:adf28cb5f5bf47d5d00f2dd7fdf5feebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61975076742eeaa78db5ccdaeed32b22"><td class="memItemLeft" align="right" valign="top"><a id="a61975076742eeaa78db5ccdaeed32b22"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getVerticies</b> () const -&gt; PtrVector&lt; <a class="el" href="structScheduledNode.html">ScheduledNode</a> &gt;</td></tr>
<tr class="separator:a61975076742eeaa78db5ccdaeed32b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d8eb7730555b9c06ce07945c265d20"><td class="memItemLeft" align="right" valign="top"><a id="ab8d8eb7730555b9c06ce07945c265d20"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getMemoryAccesses</b> () const -&gt; PtrVector&lt; <a class="el" href="structMemoryAccess.html">MemoryAccess</a> * &gt;</td></tr>
<tr class="separator:ab8d8eb7730555b9c06ce07945c265d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b1f28aa895ef131b3ed95717e78cbc"><td class="memItemLeft" align="right" valign="top"><a id="a14b1f28aa895ef131b3ed95717e78cbc"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getMemoryAccesses</b> () -&gt; MutPtrVector&lt; <a class="el" href="structMemoryAccess.html">MemoryAccess</a> * &gt;</td></tr>
<tr class="separator:a14b1f28aa895ef131b3ed95717e78cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84935407e55a56890464e70c4d26248"><td class="memItemLeft" align="right" valign="top"><a id="ac84935407e55a56890464e70c4d26248"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getMemoryAccess</b> (size_t i) -&gt; <a class="el" href="structMemoryAccess.html">MemoryAccess</a> *</td></tr>
<tr class="separator:ac84935407e55a56890464e70c4d26248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c96533c9ad334601cf7770457bc3dd3"><td class="memItemLeft" align="right" valign="top"><a id="a7c96533c9ad334601cf7770457bc3dd3"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (size_t i) -&gt; <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;</td></tr>
<tr class="separator:a7c96533c9ad334601cf7770457bc3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d5b5298470ef7f2d9ca8ee740434c4"><td class="memItemLeft" align="right" valign="top"><a id="ac0d5b5298470ef7f2d9ca8ee740434c4"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> (size_t i) const -&gt; const <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;</td></tr>
<tr class="separator:ac0d5b5298470ef7f2d9ca8ee740434c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26398ac98e014e0ef39e25c0b8da3d88"><td class="memItemLeft" align="right" valign="top"><a id="a26398ac98e014e0ef39e25c0b8da3d88"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getNodes</b> () -&gt; MutPtrVector&lt; <a class="el" href="structScheduledNode.html">ScheduledNode</a> &gt;</td></tr>
<tr class="separator:a26398ac98e014e0ef39e25c0b8da3d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9700e99d07e2a345bc3b007c5b61ad"><td class="memItemLeft" align="right" valign="top"><a id="a9e9700e99d07e2a345bc3b007c5b61ad"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>getEdges</b> () -&gt; MutPtrVector&lt; <a class="el" href="classDependence.html">Dependence</a> &gt;</td></tr>
<tr class="separator:a9e9700e99d07e2a345bc3b007c5b61ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79288a1b82169777a183f85237f8599"><td class="memItemLeft" align="right" valign="top"><a id="aa79288a1b82169777a183f85237f8599"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>numNodes</b> () const -&gt; size_t</td></tr>
<tr class="separator:aa79288a1b82169777a183f85237f8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d81ddbf07e802f1fdb4d953370e5962"><td class="memItemLeft" align="right" valign="top"><a id="a6d81ddbf07e802f1fdb4d953370e5962"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>numEdges</b> () const -&gt; size_t</td></tr>
<tr class="separator:a6d81ddbf07e802f1fdb4d953370e5962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a2b8f97f39d0dc4d4d3e207f33b79a"><td class="memItemLeft" align="right" valign="top"><a id="a86a2b8f97f39d0dc4d4d3e207f33b79a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>numMemoryAccesses</b> () const -&gt; size_t</td></tr>
<tr class="separator:a86a2b8f97f39d0dc4d4d3e207f33b79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c4ce2a218a9e11dbb5a00639548bf0"><td class="memItemLeft" align="right" valign="top"><a id="a54c4ce2a218a9e11dbb5a00639548bf0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>outNeighbors</b> (size_t idx) -&gt; <a class="el" href="structLinearProgramLoopBlock_1_1OutNeighbors.html">OutNeighbors</a></td></tr>
<tr class="separator:a54c4ce2a218a9e11dbb5a00639548bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa271dbd6a12df5de96419bf371f59721"><td class="memItemLeft" align="right" valign="top"><a id="aa271dbd6a12df5de96419bf371f59721"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>calcMaxDepth</b> () const -&gt; size_t</td></tr>
<tr class="separator:aa271dbd6a12df5de96419bf371f59721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c267ca49c6e8f135802004abe4eba9"><td class="memItemLeft" align="right" valign="top"><a id="a50c267ca49c6e8f135802004abe4eba9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (<a class="el" href="structMemoryAccess.html">MemoryAccess</a> &amp;mai, <a class="el" href="structMemoryAccess.html">MemoryAccess</a> &amp;maj)</td></tr>
<tr class="separator:a50c267ca49c6e8f135802004abe4eba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d76b0e8c6b7a221850327644f09dbb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearProgramLoopBlock.html#a1d76b0e8c6b7a221850327644f09dbb2">fillEdges</a> ()</td></tr>
<tr class="separator:a1d76b0e8c6b7a221850327644f09dbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920535b99ba5bc666835c9d4ac84ff2b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearProgramLoopBlock.html#a920535b99ba5bc666835c9d4ac84ff2b">searchValueForStores</a> (aset&lt; llvm::User * &gt; &amp;visited, <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;node, amap&lt; llvm::User *, unsigned &gt; &amp;userToMemory, llvm::User *user, unsigned nodeIndex) -&gt; bool</td></tr>
<tr class="separator:a920535b99ba5bc666835c9d4ac84ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96e9353d7339063b7035e8aea0be6ab"><td class="memItemLeft" align="right" valign="top"><a id="af96e9353d7339063b7035e8aea0be6ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkUserForLoads</b> (aset&lt; llvm::User * &gt; &amp;visited, <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;node, amap&lt; llvm::User *, unsigned &gt; &amp;userToMemory, llvm::User *user, unsigned nodeIndex)</td></tr>
<tr class="separator:af96e9353d7339063b7035e8aea0be6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419ffee319b60a0d8594b3ee7533b4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearProgramLoopBlock.html#a419ffee319b60a0d8594b3ee7533b4ff">searchOperandsForLoads</a> (aset&lt; llvm::User * &gt; &amp;visited, <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;node, amap&lt; llvm::User *, unsigned &gt; &amp;userToMemory, llvm::User *u, unsigned nodeIndex)</td></tr>
<tr class="separator:a419ffee319b60a0d8594b3ee7533b4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157c2506749e248374f59a6c5b2acea1"><td class="memItemLeft" align="right" valign="top"><a id="a157c2506749e248374f59a6c5b2acea1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connect</b> (unsigned inIndex, unsigned outIndex)</td></tr>
<tr class="separator:a157c2506749e248374f59a6c5b2acea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232293ff6bc3e04153cbab1a2fa722f9"><td class="memItemLeft" align="right" valign="top"><a id="a232293ff6bc3e04153cbab1a2fa722f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connect</b> (const <a class="el" href="structBitSet.html">BitSet</a> &amp;inIndexSet, const <a class="el" href="structBitSet.html">BitSet</a> &amp;outIndexSet)</td></tr>
<tr class="separator:a232293ff6bc3e04153cbab1a2fa722f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b8e6e6c334ba725c32e7412bdf0fe9"><td class="memItemLeft" align="right" valign="top"><a id="a38b8e6e6c334ba725c32e7412bdf0fe9"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>calcNumStores</b> () const -&gt; size_t</td></tr>
<tr class="separator:a38b8e6e6c334ba725c32e7412bdf0fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a5af74d3682d24abc08a0490b55da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearProgramLoopBlock.html#a07a5af74d3682d24abc08a0490b55da8">connectGraph</a> ()</td></tr>
<tr class="separator:a07a5af74d3682d24abc08a0490b55da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eda5c24ab3f42f6348291b6ead89240"><td class="memItemLeft" align="right" valign="top"><a id="a0eda5c24ab3f42f6348291b6ead89240"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildGraph</b> ()</td></tr>
<tr class="separator:a0eda5c24ab3f42f6348291b6ead89240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b43494ac1c7b643efbcc6b9b081cb8"><td class="memItemLeft" align="right" valign="top"><a id="a88b43494ac1c7b643efbcc6b9b081cb8"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>fullGraph</b> () -&gt; <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:a88b43494ac1c7b643efbcc6b9b081cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f525f8674897c05393733ecca2f53"><td class="memItemLeft" align="right" valign="top"><a id="a7b6f525f8674897c05393733ecca2f53"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optOrth</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> g) -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:a7b6f525f8674897c05393733ecca2f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0c845d60fc79aee571fbf7bb1c4cf9"><td class="memItemLeft" align="right" valign="top"><a id="afe0c845d60fc79aee571fbf7bb1c4cf9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>countNumLambdas</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d) const -&gt; size_t</td></tr>
<tr class="separator:afe0c845d60fc79aee571fbf7bb1c4cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a89d298b1594ca1f554dc0ca9e3ad93"><td class="memItemLeft" align="right" valign="top"><a id="a6a89d298b1594ca1f554dc0ca9e3ad93"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>countNumBoundingCoefs</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d) const -&gt; size_t</td></tr>
<tr class="separator:a6a89d298b1594ca1f554dc0ca9e3ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255c6bd9820eed2a716e40df42db71ae"><td class="memItemLeft" align="right" valign="top"><a id="a255c6bd9820eed2a716e40df42db71ae"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>countAuxParamsAndConstraints</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d)</td></tr>
<tr class="separator:a255c6bd9820eed2a716e40df42db71ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e1bf4908b664d80dbd5a9713af036e"><td class="memItemLeft" align="right" valign="top"><a id="aa1e1bf4908b664d80dbd5a9713af036e"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>addMemory</b> (<a class="el" href="structMemoryAccess.html">MemoryAccess</a> *m)</td></tr>
<tr class="separator:aa1e1bf4908b664d80dbd5a9713af036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcedfddee8c76b21d7c8b0baf82254d9"><td class="memItemLeft" align="right" valign="top"><a id="abcedfddee8c76b21d7c8b0baf82254d9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;node, size_t d) const -&gt; bool</td></tr>
<tr class="separator:abcedfddee8c76b21d7c8b0baf82254d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc8139e9f17b8070d7c6df89d1d8bd5"><td class="memItemLeft" align="right" valign="top"><a id="a2cc8139e9f17b8070d7c6df89d1d8bd5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;node) const -&gt; bool</td></tr>
<tr class="separator:a2cc8139e9f17b8070d7c6df89d1d8bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee1467a7c1939d9b8d160af2ea1eda0"><td class="memItemLeft" align="right" valign="top"><a id="a9ee1467a7c1939d9b8d160af2ea1eda0"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>setScheduleMemoryOffsets</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d)</td></tr>
<tr class="separator:a9ee1467a7c1939d9b8d160af2ea1eda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6205b023ab029b2f33a1be92aecd741c"><td class="memItemLeft" align="right" valign="top"><a id="a6205b023ab029b2f33a1be92aecd741c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>validateEdges</b> ()</td></tr>
<tr class="separator:a6205b023ab029b2f33a1be92aecd741c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a142120e6fee8467975cfff916922e4"><td class="memItemLeft" align="right" valign="top"><a id="a3a142120e6fee8467975cfff916922e4"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>instantiateOmniSimplex</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d, bool satisfyDeps) -&gt; <a class="el" href="structOptional.html">Optional</a>&lt; <a class="el" href="classSimplex.html">Simplex</a> * &gt;</td></tr>
<tr class="separator:a3a142120e6fee8467975cfff916922e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ad48e61813e3275051d90d0268a566"><td class="memItemLeft" align="right" valign="top"><a id="ad2ad48e61813e3275051d90d0268a566"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>solveGraphCore</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, bool satisfyDeps) -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:ad2ad48e61813e3275051d90d0268a566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86362bad7387df72ffaeda73820be4c"><td class="memItemLeft" align="right" valign="top"><a id="ac86362bad7387df72ffaeda73820be4c"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>solveGraph</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, bool satisfyDeps) -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:ac86362bad7387df72ffaeda73820be4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859e1676a4ef926b556d2c2b7aa501c0"><td class="memItemLeft" align="right" valign="top"><a id="a859e1676a4ef926b556d2c2b7aa501c0"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>deactivateSatisfiedEdges</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, <a class="el" href="structSimplex_1_1Solution.html">Simplex::Solution</a> sol) -&gt; <a class="el" href="structBitSet.html">BitSet</a></td></tr>
<tr class="separator:a859e1676a4ef926b556d2c2b7aa501c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e21ac83ecc396afef751fcf2b0cd61a"><td class="memItemLeft" align="right" valign="top"><a id="a8e21ac83ecc396afef751fcf2b0cd61a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateSchedules</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth, <a class="el" href="structSimplex_1_1Solution.html">Simplex::Solution</a> sol)</td></tr>
<tr class="separator:a8e21ac83ecc396afef751fcf2b0cd61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f2225677d07ce27170c584171ab419"><td class="memItemLeft" align="right" valign="top"><a id="a56f2225677d07ce27170c584171ab419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addIndependentSolutionConstraints</b> (<a class="el" href="structNotNull.html">NotNull</a>&lt; <a class="el" href="classSimplex.html">Simplex</a> &gt; omniSimplex, const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth)</td></tr>
<tr class="separator:a56f2225677d07ce27170c584171ab419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444c7b62050dfab63ec23668fc2847d5"><td class="memItemLeft" align="right" valign="top"><a id="a444c7b62050dfab63ec23668fc2847d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSchedulesIndependent</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t depth)</td></tr>
<tr class="separator:a444c7b62050dfab63ec23668fc2847d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d1cc12b31f844d6e43d3940949bf83"><td class="memItemLeft" align="right" valign="top"><a id="a71d1cc12b31f844d6e43d3940949bf83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetPhiOffsets</b> ()</td></tr>
<tr class="separator:a71d1cc12b31f844d6e43d3940949bf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c17c37c04e16c21cd106c9c1ce62789"><td class="memItemLeft" align="right" valign="top"><a id="a0c17c37c04e16c21cd106c9c1ce62789"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classDependence.html">Dependence</a> &amp;e, size_t d) -&gt; bool</td></tr>
<tr class="separator:a0c17c37c04e16c21cd106c9c1ce62789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5bd197b87aa4e24069a61d120276c4"><td class="memItemLeft" align="right" valign="top"><a id="a6f5bd197b87aa4e24069a61d120276c4"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>canFuse</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g0, <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g1, size_t d) -&gt; bool</td></tr>
<tr class="separator:a6f5bd197b87aa4e24069a61d120276c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2278f2e81797f5e98d48db7f4dd9b419"><td class="memItemLeft" align="right" valign="top"><a id="a2278f2e81797f5e98d48db7f4dd9b419"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>breakGraph</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> g, size_t d) -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:a2278f2e81797f5e98d48db7f4dd9b419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a2c23127b39d84c8bcff2bd6b3b4e"><td class="memItemLeft" align="right" valign="top"><a id="ab07a2c23127b39d84c8bcff2bd6b3b4e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optimizeLevel</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, size_t d) -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:ab07a2c23127b39d84c8bcff2bd6b3b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072e9310d762dfb51689ae6d5ad23a54"><td class="memItemLeft" align="right" valign="top"><a id="a072e9310d762dfb51689ae6d5ad23a54"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optimizeSatDep</b> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> g, size_t d, size_t maxDepth, <a class="el" href="structBitSet.html">BitSet</a> depSatLevel, const <a class="el" href="structBitSet.html">BitSet</a> &amp;depSatNest, <a class="el" href="structBitSet.html">BitSet</a> activeEdges) -&gt; <a class="el" href="structBitSet.html">BitSet</a></td></tr>
<tr class="separator:a072e9310d762dfb51689ae6d5ad23a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184cd91f49d81ad3b0fd24a016f12509"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearProgramLoopBlock.html#a184cd91f49d81ad3b0fd24a016f12509">optimize</a> (<a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> g, size_t d, size_t maxDepth) -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:a184cd91f49d81ad3b0fd24a016f12509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dfc15bb163d07ce6a88df23125d81a"><td class="memItemLeft" align="right" valign="top"><a id="a98dfc15bb163d07ce6a88df23125d81a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> () -&gt; std::optional&lt; <a class="el" href="structBitSet.html">BitSet</a> &gt;</td></tr>
<tr class="separator:a98dfc15bb163d07ce6a88df23125d81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2fe756cea77b64c3cdf5e5ad0de4f0d1"><td class="memItemLeft" align="right" valign="top">static constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearProgramLoopBlock.html#a2fe756cea77b64c3cdf5e5ad0de4f0d1">pushToEdgeVector</a> (Vector&lt; <a class="el" href="classDependence.html">Dependence</a> &gt; &amp;vec, <a class="el" href="classDependence.html">Dependence</a> dep)</td></tr>
<tr class="separator:a2fe756cea77b64c3cdf5e5ad0de4f0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07783ad0d4f003076db2913e8d2e3aad"><td class="memItemLeft" align="right" valign="top"><a id="a07783ad0d4f003076db2913e8d2e3aad"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>connects</b> (const <a class="el" href="classDependence.html">Dependence</a> &amp;e, <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g0, <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g1) -&gt; bool</td></tr>
<tr class="separator:a07783ad0d4f003076db2913e8d2e3aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a0787ba9f3116a44e820e2c0be32d5"><td class="memItemLeft" align="right" valign="top"><a id="af5a0787ba9f3116a44e820e2c0be32d5"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>getOverlapIndex</b> (const <a class="el" href="classDependence.html">Dependence</a> &amp;edge) -&gt; <a class="el" href="structOptional.html">Optional</a>&lt; size_t &gt;</td></tr>
<tr class="separator:af5a0787ba9f3116a44e820e2c0be32d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6003922ad01c64bbc164c759acf3fb7"><td class="memItemLeft" align="right" valign="top"><a id="ad6003922ad01c64bbc164c759acf3fb7"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="structMemoryAccess.html">MemoryAccess</a> &amp;mem) -&gt; bool</td></tr>
<tr class="separator:ad6003922ad01c64bbc164c759acf3fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e215962f5a1b4e51db3a767d7dd22"><td class="memItemLeft" align="right" valign="top"><a id="a8d3e215962f5a1b4e51db3a767d7dd22"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hasActiveEdges</b> (const <a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="structMemoryAccess.html">MemoryAccess</a> &amp;mem, size_t d) -&gt; bool</td></tr>
<tr class="separator:a8d3e215962f5a1b4e51db3a767d7dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe301088418feb6a6479f90269973bec"><td class="memItemLeft" align="right" valign="top"><a id="abe301088418feb6a6479f90269973bec"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>updateConstraints</b> (MutPtrMatrix&lt; int64_t &gt; C, const <a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;node, PtrMatrix&lt; int64_t &gt; sat, PtrMatrix&lt; int64_t &gt; bnd, size_t d, Row c, Row cc, Row ccc)</td></tr>
<tr class="separator:abe301088418feb6a6479f90269973bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3fc15f234aa7e560125381c2381676"><td class="memItemLeft" align="right" valign="top"><a id="a7a3fc15f234aa7e560125381c2381676"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>lexSign</b> (PtrVector&lt; int64_t &gt; x) -&gt; int64_t</td></tr>
<tr class="separator:a7a3fc15f234aa7e560125381c2381676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1435d31cdc77012b890a2976c033ec7e"><td class="memItemLeft" align="right" valign="top"><a id="a1435d31cdc77012b890a2976c033ec7e"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMask</b> (const AbstractVector auto &amp;x) -&gt; uint64_t</td></tr>
<tr class="separator:a1435d31cdc77012b890a2976c033ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ef0659e178c471db8d33a726c13e2f"><td class="memItemLeft" align="right" valign="top"><a id="ac3ef0659e178c471db8d33a726c13e2f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMasks</b> (Vector&lt; uint64_t &gt; &amp;masks, const AbstractMatrix auto &amp;A)</td></tr>
<tr class="separator:ac3ef0659e178c471db8d33a726c13e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d82d3f1ba88e9e3354530f77e9ab05"><td class="memItemLeft" align="right" valign="top"><a id="ab7d82d3f1ba88e9e3354530f77e9ab05"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMasks</b> (const AbstractMatrix auto &amp;A) -&gt; Vector&lt; uint64_t &gt;</td></tr>
<tr class="separator:ab7d82d3f1ba88e9e3354530f77e9ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b91c94c3f0fa2966f7ff2bb4fdc7f0"><td class="memItemLeft" align="right" valign="top"><a id="a18b91c94c3f0fa2966f7ff2bb4fdc7f0"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>nonZeroMask</b> (const AbstractMatrix auto A) -&gt; uint64_t</td></tr>
<tr class="separator:a18b91c94c3f0fa2966f7ff2bb4fdc7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5d60a366db975c30da3dea7b9d93f597"><td class="memItemLeft" align="right" valign="top"><a id="a5d60a366db975c30da3dea7b9d93f597"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (llvm::raw_ostream &amp;os, const <a class="el" href="classLinearProgramLoopBlock.html">LinearProgramLoopBlock</a> &amp;lblock) -&gt; llvm::raw_ostream &amp;</td></tr>
<tr class="separator:a5d60a366db975c30da3dea7b9d93f597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A loop block is a block of the program that may include multiple loops. These loops are either all executed (note iteration count may be 0, or loops may be in rotated form and the guard prevents execution; this is okay and counts as executed for our purposes here ), or none of them are. That is, the LoopBlock does not contain divergent control flow, or guards unrelated to loop bounds. The loops within a LoopBlock are optimized together, so we can consider optimizations such as reordering or fusing them together as a set.</p>
<p>Initially, the <code>LoopBlock</code> is initialized as a set of <code>Read</code> and <code>Write</code>s, without any dependence polyhedra. Then, it builds <code>DependencePolyhedra</code>. These can be used to construct an ILP.</p>
<p>That is: fields that must be provided/filled:</p><ul>
<li>refs</li>
<li>memory</li>
<li>userToMemory fields it self-initializes:</li>
</ul>
<p>NOTE: w/ respect to index linearization (e.g., going from Cartesian indexing to linear indexing), the current behavior will be to fully delinearize as a preprocessing step. Linear indexing may be used later as an optimization. This means that not only do we want to delinearize for (n = 0; n &lt; N; ++n){ for (m = 0; m &lt; M; ++m){ C(m + n*M) } } we would also want to delinearize for (i = 0; i &lt; M*N; ++i){ C(i) } into for (n = 0; n &lt; N; ++n){ for (m = 0; m &lt; M; ++m){ C(m, n) } } and then relinearize as an optimization later. Then we can compare fully delinearized loop accesses. Should be in same block: s = 0 for (i = eachindex(x)){ s += x[i]; // Omega = [0, _, 0] } m = s / length(x); // Omega = [1] for (i = eachindex(y)){ f(m, ...); // Omega = [2, _, 0] } </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a07a5af74d3682d24abc08a0490b55da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a5af74d3682d24abc08a0490b55da8">&#9670;&nbsp;</a></span>connectGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LinearProgramLoopBlock::connectGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When connecting a graph, we draw direct connections between stores and loads loads may be duplicated across stores to allow for greater reordering flexibility (which should generally reduce the ultimate amount of loads executed in the eventual generated code) </p>

</div>
</div>
<a id="a1d76b0e8c6b7a221850327644f09dbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d76b0e8c6b7a221850327644f09dbb2">&#9670;&nbsp;</a></span>fillEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LinearProgramLoopBlock::fillEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>fills all the edges between memory accesses, checking for dependencies. </p>

</div>
</div>
<a id="a184cd91f49d81ad3b0fd24a016f12509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184cd91f49d81ad3b0fd24a016f12509">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LinearProgramLoopBlock::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLinearProgramLoopBlock_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;<a class="el" href="structBitSet.html">BitSet</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>optimize at depth <code>d</code> receives graph by value, so that it is not invalidated when recursing </p>

</div>
</div>
<a id="a2fe756cea77b64c3cdf5e5ad0de4f0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe756cea77b64c3cdf5e5ad0de4f0d1">&#9670;&nbsp;</a></span>pushToEdgeVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr void LinearProgramLoopBlock::pushToEdgeVector </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; <a class="el" href="classDependence.html">Dependence</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDependence.html">Dependence</a>&#160;</td>
          <td class="paramname"><em>dep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NOTE: this relies on two important assumptions:</p><ol type="1">
<li>Code has been fully delinearized, so that axes all match (this means that even C[i], 0&lt;=i&lt;M*N -&gt; C[m*M*n]) (TODO: what if we have C[n+N*m] and C[m+M*n]???) (this of course means we have to see other uses in deciding whether to expand <code>C[i]</code>, and what to expand it into.)</li>
<li>Reduction targets have been orthogonalized, so that the number of axes reflects the number of loops they depend on. if we have for (i = I, j = J, m = M, n = N) { C(m,n) = foo(C(m,n), ...) } then we have dependencies that the load C(m,n) [ i = x, j = y ] happens after the store C(m,n) [ i = x-1, j = y], and happens after the store C(m,n) [ i = x, j = y-1] and that the store C(m,n) [ i = x, j = y ] happens after the load C(m,n) [ i = x-1, j = y], and happens after the load C(m,n) [ i = x, j = y-1] </li>
</ol>

</div>
</div>
<a id="a419ffee319b60a0d8594b3ee7533b4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419ffee319b60a0d8594b3ee7533b4ff">&#9670;&nbsp;</a></span>searchOperandsForLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LinearProgramLoopBlock::searchOperandsForLoads </td>
          <td>(</td>
          <td class="paramtype">aset&lt; llvm::User * &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amap&lt; llvm::User *, unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>userToMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::User *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We search uses of user <code>u</code> for any stores so that we can assign the use and the store the same schedule. This is done because it is assumed the data is held in registers (or, if things go wrong, spilled to the stack) in between a load and a store. A complication is that LLVM IR can be messy, e.g. we may have x = load a y = call foo(x) store y, b z = call bar(y) store z, c here, we might lock all three operations together. However, this limits reordering opportunities; we thus want to insert a new load instruction so that we have: x = load a y = call foo(x) store y, b y.reload = load b z = call bar(y.reload) store z, c and we create a new edge from <code>store y, b</code> to <code>load b</code>. </p>

</div>
</div>
<a id="a920535b99ba5bc666835c9d4ac84ff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920535b99ba5bc666835c9d4ac84ff2b">&#9670;&nbsp;</a></span>searchValueForStores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LinearProgramLoopBlock::searchValueForStores </td>
          <td>(</td>
          <td class="paramtype">aset&lt; llvm::User * &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structScheduledNode.html">ScheduledNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amap&lt; llvm::User *, unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>userToMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::User *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>used in searchOperandsForLoads if an operand is stored, we can reload it. This will insert a new store memory access.</p>
<p>If an instruction was stored somewhere, we don't keep searching for placed it was loaded, and instead add a reload. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="LoopBlock_8hpp_source.html">LoopBlock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
